<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: GO - Risen Sun&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Risen Sun&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Risen Sun&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="stay hungry, stay foolish."><meta property="og:type" content="blog"><meta property="og:title" content="Risen Sun&#039;s Blog"><meta property="og:url" content="https://yoyolikescici.github.io/"><meta property="og:site_name" content="Risen Sun&#039;s Blog"><meta property="og:description" content="stay hungry, stay foolish."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yoyolikescici.github.io/img/og_image.png"><meta property="article:author" content="孙起"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yoyolikescici.github.io"},"headline":"Risen Sun's Blog","image":["https://yoyolikescici.github.io/img/og_image.png"],"author":{"@type":"Person","name":"孙起"},"description":"stay hungry, stay foolish."}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/one.png" alt="Risen Sun&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/yoyolikescici"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">GO</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-09T09:20:21.635Z" title="2022/2/9 17:20:21">2022-02-09</time>发表</span><span class="level-item"><time dateTime="2022-02-09T09:21:44.884Z" title="2022/2/9 17:21:44">2022-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/">重剑无锋</a><span> / </span><a class="link-muted" href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></span><span class="level-item">2 小时读完 (大约16207个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/09/Tutorial%20for%20vim-go/">Tutorial for vim-go - 转载</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://www.5axxw.com/wiki/content/wo6s81#alternate-files">https://www.5axxw.com/wiki/content/wo6s81#alternate-files</a></p>
<p>( 如需查看英文版本，请 点击这里 )</p>
<h1 id="存档项目。无需维护。"><a href="#存档项目。无需维护。" class="headerlink" title="存档项目。无需维护。"></a>存档项目。无需维护。</h1><p>此项目不再维护，已存档。如果需要的话，你可以自由选择，做出自己的改变。更多细节请阅读我的博客文章：从我的项目中无限期休假</p>
<p>感谢大家的宝贵反馈和贡献。</p>
<p>vim-go教程。一个关于如何安装和使用vim-go的简单教程。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><a href="javascript:void(0);">Quick Setup</a></li>
<li><a href="javascript:void(0);">Hello World</a></li>
<li><a href="javascript:void(0);">Build it</a></li>
<li><a href="javascript:void(0);">Cover it</a></li>
<li><a href="javascript:void(0);">Edit it</a></li>
</ol>
<ul>
<li><a href="javascript:void(0);">Alternate files</a></li>
<li>转到定义</li>
<li>在函数之间移动</li>
</ul>
<ol>
<li><a href="javascript:void(0);">Understand it</a></li>
</ol>
<ul>
<li><a href="javascript:void(0);">Documentation Lookup</a></li>
<li><a href="javascript:void(0);">Identifier resolution</a></li>
<li>依赖项和文件</li>
<li>实现接口的方法存根</li>
</ul>
<h1 id="Quick-Setup"><a href="#Quick-Setup" class="headerlink" title="Quick Setup"></a>Quick Setup</h1><p>我们将使用<code>vim-plug</code>来安装vim-go。请随意使用其他插件管理器。我们将创建一个最小的<code>~/.vimrc</code>，并在继续的过程中添加它。</p>
<p>首先获取并安装<code>vim-plug</code>和<code>vim-go</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~&#x2F;.vim&#x2F;autoload&#x2F;plug.vim --create-dirs https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;junegunn&#x2F;vim-plug&#x2F;master&#x2F;plug.vim</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fatih&#x2F;vim-go.git ~&#x2F;.vim&#x2F;plugged&#x2F;vim-go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用以下内容创建<code>~/.vimrc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug &#39;fatih&#x2F;vim-go&#39;, &#123; &#39;do&#39;: &#39;:GoInstallBinaries&#39; &#125;</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者打开Vim并执行<code>:GoInstallBinaries</code>。这是一个<code>vim-go</code>命令，它为您安装所有<code>vim-go</code>依赖项。它不下载预编译的二进制文件，而是在后台调用<code>go get</code>，因此二进制文件都在主机中编译（这既安全又简化了安装过程，因为我们不需要为多个平台提供二进制文件）。如果您已经有一些依赖项（例如<code>guru</code>，<code>goimports</code>），请调用<code>:GoUpdateBinaries</code>来更新二进制文件。</p>
<p>在本教程中，我们所有的例子都在<code>GOPATH/src/github.com/fatih/vim-go-tutorial/</code>下。请确保您在该文件夹中。这将使您更容易地遵循教程。如果已经有<code>GOPATH</code>设置，请执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;fatih&#x2F;vim-go-tutorial</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者根据需要创建文件夹。</p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>从终端打开<code>main.go</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim main.go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个将<code>vim-go</code>打印到stdout的非常基本的文件。</p>
<h1 id="Run-it"><a href="#Run-it" class="headerlink" title="Run it"></a>Run it</h1><p>您可以使用<code>:GoRun %</code>轻松运行该文件。在引擎盖下，它为当前文件调用<code>go run</code>。您应该看到它打印了<code>vim-go</code>。</p>
<p>对于使用<code>:GoRun</code>运行的整个包。</p>
<h1 id="Build-it"><a href="#Build-it" class="headerlink" title="Build it"></a>Build it</h1><p>将<code>vim-go</code>替换为<code>Hello Gophercon</code>。让我们编译这个文件，而不是运行它。我们有<code>:GoBuild</code>。如果您调用它，您应该看到以下消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim-go: [build] SUCCESS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在引擎盖下面它叫<code>go build</code>，但它更聪明一点。它做了一些不同的事情：</p>
<ul>
<li>不创建二进制文件；您可以多次调用<code>:GoBuild</code>，而不会污染您的工作区。</li>
<li>它会自动<code>cd</code>s到源包的目录中</li>
<li>它分析任何错误并在快速修复列表中显示它们</li>
<li>它自动检测GOPATH并在需要时修改它（检测诸如<code>gb</code>、<code>Godeps</code>、etc..）等项目</li>
<li>如果在Vim8.0.xxx或NeoVim中使用，则运行异步</li>
</ul>
<h1 id="Fix-it"><a href="#Fix-it" class="headerlink" title="Fix it"></a>Fix it</h1><p>让我们通过添加两个编译错误来介绍两个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; foo()</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;Hello GopherCon&quot;)</span><br><span class="line">	a</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存文件并再次调用<code>:GoBuild</code>。</p>
<p>这次将打开quickfix视图。要在错误之间跳转，可以使用<code>:cnext</code>和<code>:cprevious</code>。让我们修复第一个错误，保存文件并再次调用<code>:GoBuild</code>。您将看到quickfix列表更新了一个错误。同时删除第二个错误，保存文件并再次调用<code>:GoBuild</code>。现在，因为不再有错误，vim-go会自动关闭quickfix窗口。</p>
<p>让我们稍微改进一下。Vim有一个名为<code>autowrite</code>的设置，如果您调用<code>:make</code>，它会自动写入文件的内容。vim-go也使用此设置。打开<code>.vimrc</code>并添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set autowrite</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，当您调用<code>:GoBuild</code>时，您不必再保存文件了。如果我们重新引入这两个错误并调用<code>:GoBuild</code>，我们现在可以通过只调用<code>:GoBuild</code>来更快地迭代。</p>
<p><code>:GoBuild</code>跳转到遇到的第一个错误。如果您不想跳转附加<code>!</code>（bang）符号：<code>:GoBuild!</code>。</p>
<p>在所有<code>go</code>命令中，例如<code>:GoRun</code>、<code>:GoInstall</code>、<code>:GoTest</code>、etc..，每当出现错误时，quickfix窗口总是会弹出。</p>
<h3 id="vimrc-improvements"><a href="#vimrc-improvements" class="headerlink" title="vimrc improvements"></a>vimrc improvements</h3><ul>
<li>您可以添加一些快捷方式，以便在快速修复列表中的错误之间切换：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map &lt;C-n&gt; :cnext&lt;CR&gt;</span><br><span class="line">map &lt;C-m&gt; :cprevious&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;a :cclose&lt;CR&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>我还使用这些快捷方式来构建和运行一个带有<code>&lt;leader&gt;b</code>和<code>&lt;leader&gt;r</code>的Go程序：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autocmd FileType go nmap &lt;leader&gt;b  &lt;Plug&gt;(go-build)</span><br><span class="line">autocmd FileType go nmap &lt;leader&gt;r  &lt;Plug&gt;(go-run)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Vim中有两种类型的错误列表。一个叫做<code>location list</code>，另一个叫<code>quickfix</code>。不幸的是，每个列表的命令是不同的。所以<code>:cnext</code>只适用于<code>quickfix</code>列表，而<code>location lists</code>则必须使用<code>:lnext</code>。<code>vim-go</code>中的一些命令打开一个位置列表，因为位置列表与一个窗口相关联，每个窗口都可以有一个单独的列表。这意味着您可以有多个窗口和多个位置列表，一个用于<code>Build</code>，一个用于<code>Check</code>，一个用于<code>Tests</code>，等等。。</li>
</ul>
<p>但是有些人喜欢只使用<code>quickfix</code>。如果将以下内容添加到<code>vimrc</code>中，则所有列表的类型都为<code>quickfix</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_list_type &#x3D; &quot;quickfix&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test-it"><a href="#Test-it" class="headerlink" title="Test it"></a>Test it</h1><p>让我们编写一个简单的函数并对该函数进行测试。添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func Bar() string &#123;</span><br><span class="line">	return &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开一个名为<code>main_test.go</code>的新文件（无论您如何打开它，从Vim内部，一个单独的Vim会话，等等）。。这取决于你）。让我们使用当前缓冲区并通过<code>:edit main_test.go</code>从Vim打开它。</p>
<p>当你打开新文件时，你会注意到一些东西。文件将自动添加包声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是由vim-go自动完成的。它检测到文件在一个有效的包中，因此基于包名创建了一个文件（在我们的例子中，包名是<code>main</code>）。如果没有文件，vim-go会自动用一个简单的主包填充内容。</p>
<p>使用以下代码更新测试文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestBar(t *testing.T) &#123;</span><br><span class="line">	result :&#x3D; Bar()</span><br><span class="line">	if result !&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting bar, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打电话<code>:GoTest</code>。您将看到以下消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim-go: [test] PASS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>:GoTest</code>在引擎盖下调用<code>go test</code>。它具有与<code>:GoBuild</code>相同的改进。如果有任何测试错误，将再次打开快速修复列表，您可以轻松地跳转到该列表。</p>
<p>另一个小的改进是您不必打开测试文件本身。你自己试试：打开<code>main.go</code>然后打<code>:GoTest</code>。您将看到测试也将为您运行。</p>
<p><code>:GoTest</code>默认10秒后超时。这很有用，因为Vim在默认情况下不是异步的。您可以使用<code>let g:go_test_timeout = &#39;10s&#39;</code>更改超时值</p>
<p>我们还有两个命令，可以方便地处理测试文件。第一个是<code>:GoTestFunc</code>。这只测试光标下的函数。让我们将测试文件（<code>main_test.go</code>）的内容更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestFoo(t *testing.T) &#123;</span><br><span class="line">	t.Error(&quot;intentional error 1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestBar(t *testing.T) &#123;</span><br><span class="line">	result :&#x3D; Bar()</span><br><span class="line">	if result !&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting bar, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestQuz(t *testing.T) &#123;</span><br><span class="line">	t.Error(&quot;intentional error 2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，当我们调用<code>:GoTest</code>时，一个快速修复窗口将打开，并显示两个错误。但是，如果进入<code>TestBar</code>函数并调用<code>:GoTestFunc</code>，您将看到我们的测试通过了！如果您有很多需要时间的测试，而您只想运行某些测试，那么这非常有用。</p>
<p>另一个test-related命令是<code>:GoTestCompile</code>。测试不仅需要成功地通过，而且还必须毫无问题地进行编译。<code>:GoTestCompile</code>编译测试文件，就像<code>:GoBuild</code>一样，并在出现错误时打开快速修复程序。但这并不能运行测试。这是非常有用的，如果你有一个大的测试，你要编辑很多。调用<code>:GoTestCompile</code>在当前测试文件中，您应该看到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim-go: [test] SUCCESS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vimrc-improvements-1"><a href="#vimrc-improvements-1" class="headerlink" title="vimrc improvements"></a>vimrc improvements</h3><ul>
<li>与<code>:GoBuild</code>一样，我们可以添加一个映射，用组合键轻松调用<code>:GoTest</code>。在<code>.vimrc</code>中添加以下内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd FileType go nmap &lt;leader&gt;t  &lt;Plug&gt;(go-test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在您可以通过<code>&lt;leader&gt;t</code>轻松测试文件</p>
<ul>
<li>让我们简化building Go文件。首先，删除前面添加的以下映射：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd FileType go nmap &lt;leader&gt;b  &lt;Plug&gt;(go-build)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们将添加一个改进的映射。为了使任何Go文件无缝，我们可以创建一个简单的Vim函数来检查Go文件的类型，并执行<code>:GoBuild</code>或<code>:GoTestCompile</code>。下面是可以添加到<code>.vimrc</code>中的帮助函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot; run :GoBuild or :GoTestCompile based on the go file</span><br><span class="line">function! s:build_go_files()</span><br><span class="line">  let l:file &#x3D; expand(&#39;%&#39;)</span><br><span class="line">  if l:file &#x3D;~# &#39;^\f\+_test\.go$&#39;</span><br><span class="line">    call go#test#Test(0, 1)</span><br><span class="line">  elseif l:file &#x3D;~# &#39;^\f\+\.go$&#39;</span><br><span class="line">    call go#cmd#Build(0)</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">autocmd FileType go nmap &lt;leader&gt;b :&lt;C-u&gt;call &lt;SID&gt;build_go_files()&lt;CR&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在只要你点击<code>&lt;leader&gt;b</code>，它就会生成你的Go文件，或者无缝地编译你的测试文件。</p>
<ul>
<li>默认情况下，leader快捷方式被定义为：<code>\</code>我已经将我的leader映射到<code>,</code>，因为我发现下面的设置更有用（将它放在.vimrc的开头）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mapleader &#x3D; &quot;,&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，通过这个设置，我们可以轻松地用<code>,b</code>构建任何测试和非测试文件。</p>
<h1 id="Cover-it"><a href="#Cover-it" class="headerlink" title="Cover it"></a>Cover it</h1><p>让我们深入到测试的世界。测试真的很重要。Go有一种非常好的方式来显示源代码的覆盖率。vim-go可以很容易地看到代码覆盖率，而不必以非常优雅的方式离开Vim。</p>
<p>让我们首先将<code>main_test.go</code>文件改回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestBar(t *testing.T) &#123;</span><br><span class="line">	result :&#x3D; Bar()</span><br><span class="line">	if result !&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting bar, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和<code>main.go</code>到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func Bar() string &#123;</span><br><span class="line">	return &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Foo() string &#123;</span><br><span class="line">	return &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Qux(v string) string &#123;</span><br><span class="line">	if v &#x3D;&#x3D; &quot;foo&quot; &#123;</span><br><span class="line">		return Foo()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if v &#x3D;&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		return Bar()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return &quot;INVALID&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在让我们打电话给<code>:GoCoverage</code>。在引擎盖下面，这叫做<code>go test -coverprofile tempfile</code>。它解析概要文件中的行，然后动态更改源代码的语法以反映覆盖率。如您所见，因为我们只对<code>Bar()</code>函数进行了测试，这是唯一一个绿色的函数。</p>
<p>要清除语法突出显示，可以调用<code>:GoCoverageClear</code>。让我们添加一个测试用例，看看覆盖率是如何变化的。将以下内容添加到<code>main_test.go</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestQuz(t *testing.T) &#123;</span><br><span class="line">	result :&#x3D; Qux(&quot;bar&quot;)</span><br><span class="line">	if result !&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting bar, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result &#x3D; Qux(&quot;qux&quot;)</span><br><span class="line">	if result !&#x3D; &quot;INVALID&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting INVALID, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们再次调用<code>:GoCoverage</code>，您将看到<code>Quz</code>函数现在也经过了测试，并且覆盖范围更广。再次调用<code>:GoCoverageClear</code>清除语法高亮显示。</p>
<p>因为调用<code>:GoCoverage</code>和<code>:GoCoverageClear</code>经常一起使用，所以有另一个命令可以方便地调用和清除结果。您也可以使用<code>:GoCoverageToggle</code>。它充当一个开关并显示覆盖范围，当再次调用时，它将清除覆盖范围。如何使用它们取决于您的工作流程。</p>
<p>最后，如果您不喜欢vim-go’s内部视图，也可以调用<code>:GoCoverageBrowser</code>。它使用<code>go tool cover</code>创建一个HTML页面，然后在默认浏览器中打开它。有些人更喜欢这个。</p>
<p>使用<code>:GoCoverageXXX</code>命令不会创建任何类型的临时文件，也不会污染您的工作流。所以你不必每次都处理删除不需要的文件。</p>
<h3 id="vimrc-improvements-2"><a href="#vimrc-improvements-2" class="headerlink" title="vimrc improvements"></a>vimrc improvements</h3><p>在<code>.vimrc</code>中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd FileType go nmap &lt;Leader&gt;c &lt;Plug&gt;(go-coverage-toggle)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这个，你可以很容易地用<code>&lt;leader&gt;c</code>调用<code>:GoCoverageToggle</code></p>
<h1 id="Edit-it"><a href="#Edit-it" class="headerlink" title="Edit it"></a>Edit it</h1><h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>让我们从一个<code>main.go</code>文件开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">     import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> fmt.Println(&quot;gopher&quot;     )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们从我们已经知道的事情开始吧。如果我们保存文件，你会看到它会自动格式化。默认情况下，它是启用的，但是如果需要，可以使用<code>let g:go_fmt_autosave = 0</code>禁用它（不确定为什么要禁用：）。我们还可以选择提供<code>:GoFmt</code>命令，它在引擎盖下运行<code>gofmt</code>。</p>
<p>让我们用大写字母打印<code>&quot;gopher&quot;</code>字符串。为此，我们将使用<code>strings</code>包。要更改定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.ToUpper(&quot;gopher&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你建立它时，你会得到一个错误，当然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.go|8| undefined: strings in strings.ToUpper</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到我们得到一个错误，因为<code>strings</code>包没有导入。vim-go有两个命令可以方便地操作导入声明。</p>
<p>我们可以很容易地去编辑文件，但是我们将使用Vim命令<code>:GoImport</code>。此命令将给定的包添加到导入路径。{via:<code>:GoImport strings</code>}运行。您将看到正在添加<code>strings</code>包。这个命令最棒的地方是它还支持完成。所以你只需输入<code>:GoImport s</code>然后点击tab。</p>
<p>我们还需要<code>:GoImportAs</code>和<code>:GoDrop</code>来编辑导入路径。<code>:GoImportAs</code>与<code>:GoImport</code>相同，但它允许更改包名。例如<code>:GoImportAs str strings</code>，将使用包名<code>str.</code>导入<code>strings</code></p>
<p>最后，<code>:GoDrop</code>可以很容易地从导入声明中删除任何导入路径。<code>:GoDrop strings</code>将从导入声明中删除它。</p>
<p>当然，操纵导入路径是2010年的事了。我们有更好的工具来处理这个案子。如果你还没听说过，那就叫<code>goimports</code>。<code>goimports</code>是<code>gofmt</code>的替代品。你有两种使用方法。第一种（也是推荐的）方法是告诉vim-go在保存文件时使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_fmt_command &#x3D; &quot;goimports&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在每当您保存文件时，<code>goimports</code>将自动格式化并重写导入声明。有些人不喜欢<code>goimports</code>，因为它在非常大的代码基上可能很慢。在本例中，我们还有<code>:GoImports</code>命令（注意末尾的<code>s</code>）。这样，您就可以显式地调用<code>goimports</code></p>
<h3 id="Text-objects"><a href="#Text-objects" class="headerlink" title="Text objects"></a>Text objects</h3><p>让我们展示更多编辑技巧。我们可以使用两个文本对象来更改函数。它们是<code>if</code>和<code>af</code>。<code>if</code>表示内部函数，它允许您选择函数外壳的内容。将<code>main.go</code>文件更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(1)</span><br><span class="line">	fmt.Println(2)</span><br><span class="line">	fmt.Println(3)</span><br><span class="line">	fmt.Println(4)</span><br><span class="line">	fmt.Println(5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将光标放在<code>func</code>关键字上，现在在<code>normal</code>模式下执行以下操作，然后看看会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到函数体被移除。因为我们使用了<code>d</code>运算符。使用<code>u</code>撤消更改。最棒的是，光标可以是从<code>func</code>关键字开始到右大括号<code>&#125;</code>的任意位置。它使用引擎盖下的刀具运动。我为vim-go显式地编写了motion来支持这样的特性。它具有很强的感知能力，因此它的性能非常好。你可能会问什么？将<code>main.go</code>改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func Bar() string &#123;</span><br><span class="line">	fmt.Println(&quot;calling bar&quot;)</span><br><span class="line"></span><br><span class="line">	foo :&#x3D; func() string &#123;</span><br><span class="line">		return &quot;foo&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以前我们使用regexp-based文本对象，这会导致问题。例如，在这个例子中，将光标放在匿名函数<code>func</code>关键字上，并以<code>normal</code>模式执行<code>dif</code>。您将看到只有匿名函数的主体被删除。</p>
<p>到目前为止，我们只使用了<code>d</code>运算符（delete）。但这取决于你。例如，您可以通过<code>vif</code>选择它，或者使用<code>yif</code>来拖动（复制）。</p>
<p>我们还有<code>af</code>，意思是<code>a function</code>。此文本对象包括整个函数声明。将<code>main.go</code>更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bar returns a the string &quot;foo&quot; even though it&#39;s named as &quot;bar&quot;. It&#39;s an</span><br><span class="line">&#x2F;&#x2F; example to be used with vim-go&#39;s tutorial to show the &#39;if&#39; and &#39;af&#39; text</span><br><span class="line">&#x2F;&#x2F; objects.</span><br><span class="line">func bar() string &#123;</span><br><span class="line">	fmt.Println(&quot;calling bar&quot;)</span><br><span class="line"></span><br><span class="line">	foo :&#x3D; func() string &#123;</span><br><span class="line">		return &quot;foo&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以这是一件伟大的事情。由于<code>motion</code>，我们对每个语法节点都有充分的了解。将光标放在<code>func</code>关键字的上方或下方或上方的任何位置（无所谓）。如果现在执行<code>vaf</code>，您将看到函数声明和doc注释都被选中了！例如，您可以用<code>daf</code>删除整个函数，您将看到注释也消失了。继续将光标放在注释的顶部，执行<code>vif</code>，然后执行<code>vaf</code>。您将看到它选择了函数体，即使光标在函数之外，或者它也选择了函数注释。</p>
<p>这真的很强大，这一切都要归功于我们从<code>let g:go_textobj_include_function_doc = 1motion</code>学到的知识。如果不希望注释成为函数声明的一部分，可以使用以下方法轻松禁用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_textobj_include_function_doc &#x3D; 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您有兴趣了解关于<code>motion</code>的更多信息，请查看我写的博客文章：将Go类型视为vim中的对象</p>
<p>（可选问题：不看<code>go/ast</code>包，doc注释是否是函数声明的一部分？）</p>
<h3 id="结构拆分和联接"><a href="#结构拆分和联接" class="headerlink" title="结构拆分和联接"></a>结构拆分和联接</h3><p>有一个很好的插件可以让你拆分或连接Go结构。它实际上不是一个Go插件，但它支持Go结构。要启用它，请将<code>plug</code>定义之间的plugin指令添加到<code>vimrc</code>中，然后在vim编辑器中执行<code>:source ~/.vimrc</code>并运行<code>:PlugInstall</code>。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug &#39;fatih&#x2F;vim-go&#39;</span><br><span class="line">Plug &#39;AndrewRadev&#x2F;splitjoin.vim&#39;</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装插件后，将<code>main.go</code>文件更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Foo struct &#123;</span><br><span class="line">	Name    string</span><br><span class="line">	Ports   []int</span><br><span class="line">	Enabled bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	foo :&#x3D; Foo&#123;Name: &quot;gopher&quot;, Ports: []int&#123;80, 443&#125;, Enabled: true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将光标放在与结构表达式相同的行上。现在输入<code>gS</code>。这将<code>split</code>将结构表达式分成多行。你甚至可以逆转它。如果光标仍在<code>foo</code>变量上，请在<code>normal</code>模式下执行<code>gJ</code>。您将看到字段定义都已联接。</p>
<p>这不使用任何AST-aware工具，因此例如，如果您在字段顶部键入<code>gJ</code>，您将看到只有两个字段被联接。</p>
<h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3><p>Vim-go支持两个流行的snippet插件。Ultisnips和neosnippet。默认情况下，如果您安装了<code>Ultisnips</code>，它就可以工作了。让我们先安装<code>ultisnips</code>。在<code>vimrc</code>中的<code>plug</code>指令之间添加它，然后在vim编辑器中执行<code>:source ~/.vimrc</code>，然后运行<code>:PlugInstall</code>。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug &#39;fatih&#x2F;vim-go&#39;</span><br><span class="line">Plug &#39;SirVer&#x2F;ultisnips&#39;</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有许多有用的片段。要查看完整列表，请查看我们当前的片段：<a target="_blank" rel="noopener" href="https://github.com/fatih/vim-go/blob/master/gosnippets/UltiSnips/go.snippets">https://github.com/fatih/vim-go/blob/master/gosnippets/UltiSnips/go.snippets</a></p>
<p>UltiSnips和YouCompleteMe可能在[tab]按钮上发生冲突</p>
<p>让我展示一下我用得最多的一些片段。将<code>main.go</code>内容更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;encoding&#x2F;json&quot;</span><br><span class="line"></span><br><span class="line">type foo struct &#123;</span><br><span class="line">	Message    string</span><br><span class="line">	Ports      []int</span><br><span class="line">	ServerName string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newFoo() (*foo, error) &#123;</span><br><span class="line">	return &amp;foo&#123;</span><br><span class="line">		Message:  &quot;foo loves bar&quot;,</span><br><span class="line">		Ports: []int&#123;80&#125;,</span><br><span class="line">		ServerName: &quot;Foo&quot;,</span><br><span class="line">	&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	res, err :&#x3D; newFoo()</span><br><span class="line"></span><br><span class="line">	out, err :&#x3D; json.Marshal(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们把光标放在<code>newFoo()</code>表达式之后。如果错误是non-nil，让我们在这里惊慌失措。在insert模式下输入<code>errp</code>，然后点击<code>tab</code>。您将看到它将被展开并将光标放在“panic（）`”函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    panic( )</span><br><span class="line">          ^</span><br><span class="line">          cursor position</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用<code>err</code>填充恐慌，然后转到<code>json.Marshal</code>语句。做同样的事情。</p>
<p>现在让我们打印变量<code>out</code>。由于变量打印非常流行，因此我们有几个片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn -&gt; fmt.Println()</span><br><span class="line">ff -&gt; fmt.Printf()</span><br><span class="line">ln -&gt; log.Println()</span><br><span class="line">lf -&gt; log.Printf()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里<code>ff</code>和<code>lf</code>是特殊的。它们还动态地将变量名复制到格式字符串中。你自己试试吧。将光标移到main函数的末尾，输入<code>ff</code>，然后点击tab。展开代码段后，可以开始键入。输入<code>string(out)</code>，您将看到格式字符串和变量参数都将用您键入的相同字符串填充。</p>
<p>这对于快速打印用于调试的变量非常方便。使用<code>:GoRun</code>运行文件，您将看到以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(out) &#x3D; &#123;&quot;Message&quot;:&quot;foo loves bar&quot;,&quot;Ports&quot;:[80],&quot;ServerName&quot;:&quot;Foo&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>伟大的。现在让我展示最后一个我认为非常有用的片段。正如您在输出中看到的，字段<code>Message</code>和<code>Ports</code>以大写字符开头。为了解决这个问题，我们可以在struct字段中添加一个json标记。vim-go使添加字段标记变得非常容易。将光标移到字段中<code>Message</code>字符串行的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line">    Message string .</span><br><span class="line">                   ^ put your cursor here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>insert</code>模式下，输入<code>json</code>并点击tab。您将看到它将自动扩展为有效的字段标记。字段名将自动转换为小写，并放在那里。现在应该可以看到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line">	Message  string &#96;json:&quot;message&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>真是太神奇了。但我们可以做得更好！继续为<code>ServerName</code>字段创建一个代码段扩展。您将看到它被转换为<code>server_name</code>。太棒了对吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line">	Message    string &#96;json:&quot;message&quot;&#96;</span><br><span class="line">	Ports      []int</span><br><span class="line">	ServerName string &#96;json:&quot;server_name&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vimrc-improvements-3"><a href="#vimrc-improvements-3" class="headerlink" title="vimrc improvements"></a>vimrc improvements</h3><ul>
<li>别忘了把<code>gofmt</code>改成<code>goimports</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_fmt_command &#x3D; &quot;goimports&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当您保存文件时，<code>gofmt</code>在解析文件期间显示任何错误。如果有任何解析错误，它会在快速修复列表中显示它们。这是默认启用的。有些人不喜欢。要禁用它，请添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_fmt_fail_silently &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>您可以在转换时更改应应用的大小写。默认情况下，vim-go使用<code>snake_case</code>。但如果您愿意，也可以使用<code>camelCase</code>。例如，如果要将默认值更改为大小写，请使用以下设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_addtags_transform &#x3D; &quot;camelcase&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Beautify-it"><a href="#Beautify-it" class="headerlink" title="Beautify it"></a>Beautify it</h1><p>默认情况下，我们只启用了有限的语法高亮显示。主要有两个原因。首先，人们不喜欢太多的颜色，因为它会让人分心。第二个原因是它对Vim的性能影响很大。我们需要显式地启用它。首先将以下设置添加到<code>.vimrc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_highlight_types &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这突出显示了<code>bar</code>和<code>foo</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type foo struct&#123;</span><br><span class="line">  quz string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type bar interface&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_highlight_fields &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将突出显示下面的<code>quz</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type foo struct&#123;</span><br><span class="line">  quz string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f :&#x3D; foo&#123;quz:&quot;QUZ&quot;&#125;</span><br><span class="line">f.quz # quz here will be highlighted</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_highlight_functions &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在还在声明中突出显示函数和方法名。<code>Foo</code>和<code>main</code>现在将突出显示，但是<code>Println</code>不是因为这是一个调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (t *T) Foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果还想突出显示函数和方法调用，请添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_highlight_function_calls &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，<code>Println</code>也将突出显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (t *T) Foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果添加<code>let g:go_highlight_operators = 1</code>，它将突出显示以下运算符，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- + % &lt; &gt; ! &amp; | ^ * &#x3D;</span><br><span class="line">-&#x3D; +&#x3D; %&#x3D; &lt;&#x3D; &gt;&#x3D; !&#x3D; &amp;&#x3D; |&#x3D; ^&#x3D; *&#x3D; &#x3D;&#x3D;</span><br><span class="line">&lt;&lt; &gt;&gt; &amp;^</span><br><span class="line">&lt;&lt;&#x3D; &gt;&gt;&#x3D; &amp;^&#x3D;</span><br><span class="line">:&#x3D; &amp;&amp; || &lt;- ++ --</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果添加<code>let g:go_highlight_extra_types = 1</code>，以下额外类型也将突出显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytes.(Buffer)</span><br><span class="line">io.(Reader|ReadSeeker|ReadWriter|ReadCloser|ReadWriteCloser|Writer|WriteCloser|Seeker)</span><br><span class="line">reflect.(Kind|Type|Value)</span><br><span class="line">unsafe.Pointer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们继续了解更多有用的亮点。构建标签呢？不查看<code>go/build</code>文档就不容易实现它。让我们首先添加以下内容：<code>let g:go_highlight_build_constraints = 1</code>并将<code>main.go</code>文件更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; build linux</span><br><span class="line">package main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你会看到它是灰色的，所以它是无效的。将<code>+</code>添加到<code>build</code>单词并再次保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; +build linux</span><br><span class="line">package main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你知道为什么吗？如果您阅读<code>go/build</code>包，您将看到以下内容隐藏在文档中：</p>
<blockquote>
<p>… 前面只有空行和其他行注释。</p>
</blockquote>
<p>让我们再次更改内容并将其保存到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; +build linux</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到它以有效的方式自动高亮显示它。真的很棒。如果您将<code>linux</code>更改为某个内容，您将看到它还检查有效的官方标记（例如<code>darwin</code>、<code>race</code>、<code>ignore</code>等）</p>
<p>另一个类似的特性是突出显示Go指令<code>//go:generate</code>。如果将<code>let g:go_highlight_generate_tags = 1</code>放入vimrc，它将突出显示使用<code>go generate</code>命令处理的有效指令。</p>
<p>我们有更多的亮点设置，这些只是一个偷窥。如需更多信息，请通过<code>:help go-settings</code>查看设置</p>
<h3 id="vimrc-improvements-4"><a href="#vimrc-improvements-4" class="headerlink" title="vimrc improvements"></a>vimrc improvements</h3><ul>
<li>有些人不喜欢标签的显示方式。默认情况下，Vim为单个选项卡显示<code>8</code>个空格。然而，如何在Vim中表示取决于我们。以下内容将更改为将单个选项卡显示为4个空格：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop&#x3D;4 shiftwidth&#x3D;4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此设置不会将选项卡展开为空格。它将用<code>4</code>空格显示一个选项卡。它将使用<code>4</code>空格来表示单个缩进。</p>
<ul>
<li>很多人要我的配色方案。我用的是稍加修改的<code>molokai</code>。要启用它，请在Plug定义之间添加Plug指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug &#39;fatih&#x2F;vim-go&#39;</span><br><span class="line">Plug &#39;fatih&#x2F;molokai&#39;</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时添加以下内容，以启用原始配色方案和256色版本的molokai：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let g:rehash256 &#x3D; 1</span><br><span class="line">let g:molokai_original &#x3D; 1</span><br><span class="line">colorscheme molokai</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后重启Vim并调用<code>:source ~/.vimrc</code>，然后调用<code>:PlugInstall</code>。这将拉插件并为您安装。安装插件后，您需要重新启动Vim。</p>
<h1 id="Check-it"><a href="#Check-it" class="headerlink" title="Check it"></a>Check it</h1><p>从前面的示例中，您看到我们有许多命令，当出现问题时，这些命令将显示quickfix窗口。例如，<code>:GoBuild</code>显示编译输出中的错误（如果有）。或者例如<code>:GoFmt</code>显示当前文件格式化时的解析错误。</p>
<p>我们有许多其他命令，允许我们调用然后收集错误、警告或建议。</p>
<p>例如<code>:GoLint</code>。在幕后，它调用<code>golint</code>，这是一个建议更改以使Go代码更具惯用性的命令。还有一个<code>:GoVet</code>，它在引擎盖下调用<code>go vet</code>。有许多其他工具可以检查某些东西。为了让它更简单，有人决定创建一个调用所有这些跳棋的工具。这个工具叫做<code>gometalinter</code>。vim-go通过命令<code>:GoMetaLinter</code>支持它。那么它有什么作用呢？</p>
<p>如果您只是调用<code>:GoMetaLinter</code>来获取给定的Go源代码。默认情况下，它将同时运行<code>go vet</code>、<code>golint</code>和<code>errcheck</code>。<code>gometalinter</code>收集所有输出并将其规范化为通用格式。因此，如果您调用<code>:GoMetaLinter</code>，vim-go将在快速修复列表中显示所有这些跳棋的结果。然后，您可以轻松地在lint、vet和errcheck结果之间切换。此默认设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_metalinter_enabled &#x3D; [&#39;vet&#39;, &#39;golint&#39;, &#39;errcheck&#39;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有许多其他工具，您可以轻松地自定义此列表。如果您调用<code>:GoMetaLinter</code>，它将自动使用上面的列表。</p>
<p>因为<code>:GoMetaLinter</code>通常很快，vim-go也可以在每次保存文件时调用它（就像<code>:GoFmt</code>）。要启用它，您需要将以下内容添加到<code>.vimrc:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_metalinter_autosave &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最棒的是，autosave的跳棋与<code>:GoMetaLinter</code>不同。这很好，因为您可以自定义它，所以在保存文件时只调用快速检查程序，但如果您调用<code>:GoMetaLinter</code>，则调用其他检查程序。下面的设置允许您为<code>autosave</code>特性定制方格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_metalinter_autosave_enabled &#x3D; [&#39;vet&#39;, &#39;golint&#39;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如您所见，默认情况下启用<code>vet</code>和<code>golint</code>。最后，为了防止<code>:GoMetaLinter</code>运行太长时间，我们有一个设置，在给定的超时之后取消它。默认为<code>5 seconds</code>，但可以通过以下设置进行更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_metalinter_deadline &#x3D; &quot;5s&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Navigate-it"><a href="#Navigate-it" class="headerlink" title="Navigate it"></a>Navigate it</h1><p>到目前为止，我们只跳过了<code>main.go</code>和<code>main_test.go</code>两个文件。如果在同一个目录中只有两个文件，那么切换非常容易。但是如果项目随着时间的推移变得越来越大呢？或者如果文件本身太大，以至于您很难导航它呢？</p>
<h3 id="Alternate-files"><a href="#Alternate-files" class="headerlink" title="Alternate files"></a>Alternate files</h3><p>vim-go有几种改进导航的方法。首先让我展示一下如何在Go源代码和它的测试文件之间快速跳转。</p>
<p>假设您有一个<code>foo.go</code>及其等价的测试文件<code>foo_test.go</code>。如果您有前面示例中的<code>main.go</code>及其测试文件，您也可以打开它。打开后，只需执行以下Vim命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoAlternate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到您立即切换到<code>main_test.go</code>。如果您再次执行它，它将切换到<code>main.go</code>。<code>:GoAlternate</code>起到切换的作用，如果您有一个包含许多测试文件的包，则非常有用。这个想法非常类似于plugina.vim命令名。这个插件在<code>.c</code>和<code>.h</code>文件之间跳跃。在我们的例子中，<code>:GoAlternate</code>用于在测试和non-test文件之间切换。</p>
<h3 id="转到定义"><a href="#转到定义" class="headerlink" title="转到定义"></a>转到定义</h3><p>最常用的特性之一是<code>go to definition</code>。从一开始，vim-go有一个<code>:GoDef</code>命令，该命令跳转到任何标识符的声明。让我们首先创建一个<code>main.go</code>文件来显示它的实际操作。使用以下内容创建它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">	Foo string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	t :&#x3D; T&#123;</span><br><span class="line">		Foo: &quot;foo&quot;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;t &#x3D; %+v\n&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们有几种跳到声明的方法。例如，如果您将光标放在<code>T</code>表达式的顶部，紧跟在main函数之后并调用<code>:GoDef</code>，它将跳转到类型声明。</p>
<p>如果您将光标放在<code>t</code>变量声明的顶部，紧跟在main函数之后并调用<code>:GoDef</code>，您将看到不会发生任何事情。因为没有地方可去，但是如果您向下滚动几行并将光标放在<code>fmt.Printf()</code>中使用的<code>t</code>变量并调用<code>:GoDef</code>，您将看到它跳转到变量声明。</p>
<p><code>:GoDef</code>不仅适用于本地范围，而且在全局范围内（跨<code>GOPATH</code>）工作。例如，如果您将光标放在<code>Printf()</code>函数的顶部并调用<code>:GoDef</code>，它将直接跳转到<code>fmt</code>包。因为这是如此频繁地使用，vim-go也覆盖了内置的Vim快捷方式<code>gd</code>和<code>ctrl-]</code>。因此，您可以轻松地使用<code>gd</code>或<code>ctrl-]</code>来代替<code>:GoDef</code></p>
<p>一旦我们跳转到一个声明，我们可能还想回到以前的位置。默认情况下，Vim快捷键<code>ctrl-o</code>会跳转到上一个光标位置。当它运行得很好时，它会很好地工作，但是如果您在Go声明之间导航，就不够好了。例如，如果您跳转到<code>:GoDef</code>的文件，然后向下滚动到底部，然后可能到顶部，<code>ctrl-o</code>也会记住这些位置。因此，如果你想在调用<code>:GoDef</code>时跳回上一个位置，你必须多次点击<code>ctrl-o</code>。这真的很烦人。</p>
<p>不过，我们不需要使用这个快捷方式，因为vim-go为您提供了更好的实现。有一个命令<code>:GoDefPop</code>正是这样做的。vim-go为使用<code>:GoDef</code>访问的所有位置保留一个内部堆栈列表。这意味着您可以通过<code>:GoDefPop</code>轻松地跳回原来的位置，即使您在文件中向下/向上滚动也可以。因为这也被使用了很多次，所以我们有一个快捷方式<code>ctrl-t</code>，它在引擎盖下调用<code>:GoDefPop</code>。所以回顾一下：</p>
<ul>
<li>使用<code>ctrl-]</code>或<code>gd</code>跳转到本地或全局定义</li>
<li>使用<code>ctrl-t</code>跳回上一个位置</li>
</ul>
<p>让我们继续问另一个问题，假设你跳得太远，只想回到你开始的地方？如前所述，vim-go保存通过<code>:GoDef</code>调用的所有位置的历史记录。有一个命令显示了所有这些，它名为<code>:GoDefStack</code>。如果您调用它，您将看到一个带有旧位置列表的自定义窗口。只需导航到所需的位置，然后按enter键。最后随时调用<code>:GoDefStackClear</code>清除堆栈列表。</p>
<h3 id="在函数之间移动"><a href="#在函数之间移动" class="headerlink" title="在函数之间移动"></a>在函数之间移动</h3><p>从前面的例子中，我们看到<code>:GoDef</code>如果您知道您想跳转到哪里，那么<code>:GoDef</code>是很好的。但是如果你不知道你的下一个目的地呢？或者你只知道一个函数的名字？</p>
<p>在我们的<code>Edit it</code>部分中，我提到了一个名为<code>motion</code>的工具，它是一个专门为vim-go定制的工具。<code>motion</code>还有其他功能。<code>motion</code>解析Go包，因此对所有声明都有很好的理解。我们可以利用这个特性在声明之间跳转。有两个命令，在安装某个插件之前是不可用的。命令包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:GoDecls</span><br><span class="line">:GoDeclsDir</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，让我们通过安装必要的插件来启用这两个命令。这个插件叫做ctrlp。Long-timeVim用户已经安装了它。要安装它，请在<code>plug</code>指令之间添加以下行，然后在vim编辑器中执行<code>:source ~/.vimrc</code>，并调用<code>:PlugInstall</code>来安装它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plug &#39;ctrlpvim&#x2F;ctrlp.vim&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装后，请使用以下<code>main.go</code>内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">	Foo string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	t :&#x3D; T&#123;</span><br><span class="line">		Foo: &quot;foo&quot;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;t &#x3D; %+v\n&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Bar() string &#123;</span><br><span class="line">	return &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BarFoo() string &#123;</span><br><span class="line">	return &quot;bar_foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以及一个<code>main_test.go</code>文件，其中包含以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type files interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func TestBar(t *testing.T) &#123;</span><br><span class="line">	result :&#x3D; Bar()</span><br><span class="line">	if result !&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting bar, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestQuz(t *testing.T) &#123;</span><br><span class="line">	result :&#x3D; Qux(&quot;bar&quot;)</span><br><span class="line">	if result !&#x3D; &quot;bar&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting bar, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result &#x3D; Qux(&quot;qux&quot;)</span><br><span class="line">	if result !&#x3D; &quot;INVALID&quot; &#123;</span><br><span class="line">		t.Errorf(&quot;expecting INVALID, got %s&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开<code>main.go</code>并调用<code>:GoDecls</code>。您将看到<code>:GoDecls</code>为您显示了所有类型和函数声明。如果您输入<code>ma</code>，您将看到<code>ctrlp</code>为您过滤列表。如果你点击<code>enter</code>，它将自动跳转到它。模糊搜索功能与<code>motion</code>的AST功能相结合，给我们带来了一个非常简单但功能强大的特性。</p>
<p>例如，调用<code>:GoDecls</code>并写入<code>foo</code>。您将看到它将为您过滤<code>BarFoo</code>。Go解析器速度非常快，可以很好地处理包含数百个声明的大型文件。</p>
<p>有时仅仅在当前文件中搜索是不够的。一个Go包可以有多个文件（例如测试）。类型声明可以在一个文件中，而特定于一组功能的某些函数可以在另一个文件中。这就是<code>:GoDeclsDir</code>有用的地方。它解析给定文件的整个目录，并列出给定目录（但不是子目录）中文件的所有声明。</p>
<p>打电话<code>:GoDeclsDir</code>。这次您将看到它还包括来自<code>main_test.go</code>文件的声明。如果您输入<code>Bar</code>，您将看到<code>Bar</code>和<code>TestBar</code>函数。如果您只想获得所有类型和函数声明的概述，并跳转到它们，这真是太棒了。</p>
<p>让我们继续问一个问题。如果你只想转到下一个或上一个函数呢？如果当前函数体很长，则很可能看不到函数名。或者在当前函数和其他函数之间还有其他声明。</p>
<p>Vim已经有了像<code>w</code>表示单词或<code>b</code>表示向后单词的运动操作符。但是如果我们可以加上行动计划呢？例如函数声明？</p>
<p>vim-go提供（重写）两个运动对象在函数之间移动。这些是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">]] -&gt; jump to next function</span><br><span class="line">[[ -&gt; jump to previous function</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，Vim有这些快捷方式。但这些都适用于C源代码和大括号之间的跳转。我们可以做得更好。就像我们前面的例子一样，<code>motion</code>是在引擎盖下用于这个操作的</p>
<p>打开<code>main.go</code>并移动到文件的顶部。在<code>normal</code>模式下，输入<code>]]</code>，然后看看会发生什么。您将看到您跳转到<code>main()</code>函数。另一个<code>]]</code>将跳转到<code>Bar()</code>，如果你点击<code>[[</code>，它将跳回<code>main()</code>函数。</p>
<p><code>]]</code>和<code>[[</code>也接受<code>counts</code>。例如，如果您再次移动到顶部并点击<code>3]]</code>，您将看到它将跳转到源文件中的第三个函数。接下来，因为这些都是有效的运动，你也可以对它应用操作符！</p>
<p>如果您将文件移到顶部并点击<code>d]]</code>，您将看到它在下一个函数之前删除了任何内容。例如，一个有用的用法是输入<code>v]]</code>，然后再次点击<code>]]</code>来选择下一个函数，直到完成选择为止。</p>
<h3 id="vimrc-improvements-5"><a href="#vimrc-improvements-5" class="headerlink" title=".vimrc improvements"></a>.vimrc improvements</h3><ul>
<li>我们可以改进它来控制它如何打开备用文件。在<code>.vimrc</code>中添加以下内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autocmd Filetype go command! -bang A call go#alternate#Switch(&lt;bang&gt;0, &#39;edit&#39;)</span><br><span class="line">autocmd Filetype go command! -bang AV call go#alternate#Switch(&lt;bang&gt;0, &#39;vsplit&#39;)</span><br><span class="line">autocmd Filetype go command! -bang AS call go#alternate#Switch(&lt;bang&gt;0, &#39;split&#39;)</span><br><span class="line">autocmd Filetype go command! -bang AT call go#alternate#Switch(&lt;bang&gt;0, &#39;tabe&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这将添加新的命令，称为<code>:A</code>、<code>:AV</code>、<code>:AS</code>和<code>:AT</code>。这里<code>:A</code>的工作方式与<code>:GoAlternate</code>相同，它用备用文件替换当前缓冲区。<code>:AV</code>将使用备用文件打开一个新的垂直拆分。<code>:AS</code>将在新的拆分视图中打开备用文件，在新选项卡中打开<code>:AT</code>。这些命令的效率非常高，这取决于您如何使用它们，所以我认为拥有它们很有用。</p>
<ul>
<li>“go to definition”命令系列非常强大，但使用起来却很简单。默认情况下，它使用工具<code>guru</code>（以前是<code>oracle</code>）。<code>guru</code>有很好的可预测性记录。它适用于点导入、供应商化导入和许多其他non-obvious标识符。但有时对于某些查询来说，它非常慢。以前vim-go使用的是<code>godef</code>，它在解决查询方面非常快。在最新版本中，可以很容易地使用或切换<code>:GoDef</code>的底层工具。要将其更改回<code>godef</code>，请使用以下设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_def_mode &#x3D; &#39;godef&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当前默认情况下，<code>:GoDecls</code>和<code>:GoDeclsDir</code>显示类型和函数声明。这可以使用<code>g:go_decls_includes</code>设置进行自定义。默认情况下，它的形式是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_decls_includes &#x3D; &quot;func,type&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只想显示函数声明，请将其更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_decls_includes &#x3D; &quot;func&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Understand-it"><a href="#Understand-it" class="headerlink" title="Understand it"></a>Understand it</h1><p>编写/编辑/更改代码通常只有在我们首先了解代码在做什么时才能做。vim-go有几种方法可以使您更容易地理解代码的全部内容。</p>
<h3 id="Documentation-lookup"><a href="#Documentation-lookup" class="headerlink" title="Documentation lookup"></a>Documentation lookup</h3><p>让我们从基础知识开始。Go文档非常well-written，并且高度集成到goast中。如果只编写一些注释，解析器可以轻松地解析它并与AST中的任何节点关联。所以这意味着我们可以很容易地以相反的顺序找到文档。如果您有一个AST节点，那么您可以轻松地从该节点读取它！</p>
<p>我们有一个名为<code>:GoDoc</code>的命令，它显示与光标下标识符相关的任何文档。让我们将<code>main.go</code>的内容更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">	fmt.Println(sayHi())</span><br><span class="line">	fmt.Println(sayYoo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sayHi() returns the string &quot;hi&quot;</span><br><span class="line">func sayHi() string &#123;</span><br><span class="line">	return &quot;hi&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayYoo() string &#123;</span><br><span class="line">	return &quot;yoo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将光标放在<code>Println</code>函数的顶部，紧跟<code>main</code>函数，然后调用<code>:GoDoc</code>。您将看到它vim-go自动打开一个草稿窗口，为您显示文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func Println(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line"></span><br><span class="line">Println formats using the default formats for its operands and writes to</span><br><span class="line">standard output. Spaces are always added between operands and a newline is</span><br><span class="line">appended. It returns the number of bytes written and any write error</span><br><span class="line">encountered.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它显示导入路径、函数签名，最后是标识符的doc注释。最初vim-go使用的是普通的<code>go doc</code>，但它有一些缺点，例如不能基于字节标识符进行解析。<code>go doc</code>非常适合终端使用，但是很难集成到编辑器中。幸运的是，我们有一个非常有用的工具<code>gogetdoc</code>，它解析并检索底层节点的AST节点，并输出相关的doc注释。</p>
<p>这就是<code>:GoDoc</code>适用于任何类型的标识符的原因。如果您将光标放在<code>sayHi()</code>下并调用<code>:GoDoc</code>，您将看到它也显示了它。如果你把它放在<code>sayYoo()</code>下，你会看到它只输出<code>no documentation</code>作为AST节点，没有doc注释。</p>
<p>与其他特性一样，我们重写默认的普通快捷方式<code>K</code>，以便它调用<code>:GoDoc</code>，而不是<code>man</code>（或其他东西）。很容易找到文档，只需在正常模式下点击<code>K</code>！</p>
<p><code>:GoDoc</code>只显示给定标识符的文档。但是它不是一个文档浏览器，如果你想浏览文档，有一个third-party插件来完成它：go-explorer。在vim-go中包含了一个开放的bug。</p>
<h3 id="Identifier-resolution"><a href="#Identifier-resolution" class="headerlink" title="Identifier resolution"></a>Identifier resolution</h3><p>有时您想知道函数接受或返回的是什么。或者光标下的标识符是什么。像这样的问题很常见，我们有命令来回答。</p>
<p>使用相同的<code>main.go</code>文件，检查<code>Println</code>函数并调用<code>:GoInfo</code>。您将看到函数签名正在状态行中打印。这真的很好的看到它在做什么，因为你不必跳到定义和检查签名是什么。</p>
<p>但是每次打<code>:GoInfo</code>都很乏味。我们可以做一些改进来更快地调用它。一如既往，加快速度的一种方法是添加快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd FileType go nmap &lt;Leader&gt;i &lt;Plug&gt;(go-info)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在只需按一下<code>&lt;leader&gt;i</code>，就可以轻松地调用<code>:GoInfo</code>。但仍有改进的余地。vim-go支持在移动光标时自动显示信息。要启用它，请在<code>.vimrc</code>中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_auto_type_info &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，只要将光标移到有效标识符上，就会看到状态行自动更新。默认情况下，它每更新一次<code>800ms</code>。这是一个vim设置，可以用<code>updatetime</code>设置进行更改。要将其更改为<code>100ms</code>，请将以下内容添加到<code>.vimrc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set updatetime&#x3D;100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Identifier-highlighting"><a href="#Identifier-highlighting" class="headerlink" title="Identifier highlighting"></a>Identifier highlighting</h3><p>有时我们只想快速看到所有匹配的标识符。例如变量、函数等。。假设您有以下Go代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">	err :&#x3D; sayHi()</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sayHi() returns the string &quot;hi&quot;</span><br><span class="line">func sayHi() error &#123;</span><br><span class="line">	fmt.Println(&quot;hi&quot;)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您将光标放在<code>err</code>上并调用<code>:GoSameIds</code>，您将看到所有的<code>err</code>变量都会高亮显示。将光标放在<code>sayHi()</code>函数调用上，您将看到<code>sayHi()</code>函数标识符都高亮显示。要清除它们，请致电<code>:GoSameIdsClear</code></p>
<p>如果我们不必每次都手动调用它，这会更有用。vim-go可以自动突出显示匹配的标识符。在<code>vimrc</code>中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_auto_sameids &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新启动vim之后，您将看到不再需要手动调用<code>:GoSameIds</code>。匹配的标识符变量现在会自动为您高亮显示。</p>
<h3 id="依赖项和文件"><a href="#依赖项和文件" class="headerlink" title="依赖项和文件"></a>依赖项和文件</h3><p>如您所知，一个包可以由多个依赖项和文件组成。即使目录中有许多文件，也只有正确包含package子句的文件才是包的一部分。</p>
<p>要查看组成包的文件，可以调用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoFiles</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将输出（my<code>$GOPATH</code>设置为<code>~/Code/Go</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;&#x2F;Users&#x2F;fatih&#x2F;Code&#x2F;go&#x2F;src&#x2F;github.com&#x2F;fatih&#x2F;vim-go-tutorial&#x2F;main.go&#39;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你有其他文件，这些也会列出。请注意，此命令仅用于列出属于构建一部分的Go文件。将不列出测试文件。</p>
<p>为了显示文件的依赖关系，可以调用<code>:GoDeps</code>。如果你叫它，你会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#39;errors&#39;, &#39;fmt&#39;, &#39;internal&#x2F;race&#39;, &#39;io&#39;, &#39;math&#39;, &#39;os&#39;, &#39;reflect&#39;, &#39;runtime&#39;,</span><br><span class="line">&#39;runtime&#x2F;internal&#x2F;atomic&#39;, &#39;runtime&#x2F;internal&#x2F;sys&#39;, &#39;strconv&#39;, &#39;sync&#39;,</span><br><span class="line">&#39;sync&#x2F;atomic &#39;, &#39;syscall&#39;, &#39;time&#39;, &#39;unicode&#x2F;utf8&#39;, &#39;unsafe&#39;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Guru"><a href="#Guru" class="headerlink" title="Guru"></a>Guru</h3><p>前一个特性是在引擎盖下使用<code>guru</code>工具。让我们来谈谈古鲁。那么什么是古鲁？Guru是一个用于导航和理解Go代码的编辑器集成工具。有一本用户手册显示了所有的特性：<a target="_blank" rel="noopener" href="https://golang.org/s/using-guru">https://golang.org/s/using-guru</a></p>
<p>让我们使用手册中的相同示例来展示我们集成到vim-go中的一些功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net&#x2F;http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	h :&#x3D; make(handler)</span><br><span class="line">	go counter(h)</span><br><span class="line">	if err :&#x3D; http.ListenAndServe(&quot;:8000&quot;, h); err !&#x3D; nil &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func counter(ch chan&lt;- int) &#123;</span><br><span class="line">	for n :&#x3D; 0; ; n++ &#123;</span><br><span class="line">		ch &lt;- n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type handler chan int</span><br><span class="line"></span><br><span class="line">func (h handler) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	w.Header().Set(&quot;Content-type&quot;, &quot;text&#x2F;plain&quot;)</span><br><span class="line">	fmt.Fprintf(w, &quot;%s: you are visitor #%d&quot;, req.URL, &lt;-h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将光标放在<code>handler</code>上，然后调用<code>:GoReferrers</code>。这将调用<code>referrers</code>模式<code>guru</code>，它查找对所选标识符的引用，扫描工作区内所有必需的包。结果将是一个位置列表。</p>
<p><code>guru</code>的模式之一也是<code>describe</code>模式。它就像<code>:GoInfo</code>，但它更高级一些（它提供了更多信息）。例如，它显示类型的方法集（如果有）。如果选中，则显示包的声明。</p>
<p>让我们继续使用相同的<code>main.go</code>文件。将光标放在<code>URL</code>字段或<code>req.URL</code>（在<code>ServeHTTP</code>函数内）的顶部。打电话给<code>:GoDescribe</code>。您将看到一个包含以下内容的位置列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main.go|27 col 48| reference to field URL *net&#x2F;url.URL</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;request.go|91 col 2| defined here</span><br><span class="line">main.go|27 col 48| Methods:</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|587 col 15| method (*URL) EscapedPath() string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|844 col 15| method (*URL) IsAbs() bool</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|851 col 15| method (*URL) Parse(ref string) (*URL, error)</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|897 col 15| method (*URL) Query() Values</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|904 col 15| method (*URL) RequestURI() string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|865 col 15| method (*URL) ResolveReference(ref *URL) *URL</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|662 col 15| method (*URL) String() string</span><br><span class="line">main.go|27 col 48| Fields:</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|310 col 2| Scheme   string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|311 col 2| Opaque   string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|312 col 2| User     *Userinfo</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|313 col 2| Host     string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|314 col 2| Path     string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|315 col 2| RawPath  string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|316 col 2| RawQuery string</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;url&#x2F;url.go|317 col 2| Fragment string</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到，我们可以看到字段的定义、方法集和<code>URL</code>结构的字段。这是一个非常有用的命令，如果您需要它并想理解周围的代码，它就在那里。尝试通过在其他各种标识符上调用<code>:GoDescribe</code>来测试输出是什么。</p>
<p>被问得最多的问题之一是如何知道一个类型正在实现的接口。假设您有一个类型和一个由多个方法组成的方法集。您想知道它可能实现哪个接口。<code>guru</code>的模式<code>implement</code>就是这样做的，它有助于找到一个类型实现的接口。</p>
<p>只需继续前一个<code>main.go</code>文件。将光标放在<code>handler</code>标识符上<code>main()</code>函数之后。Call<code>:GoImplements</code>您将看到一个位置列表，其中包含以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.go|23 col 6| chan type handler</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go|57 col 6| implements net&#x2F;http.Handler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行是我们选择的类型，第二行是它实现的接口。因为一个类型可以实现许多接口，所以它是一个位置列表。</p>
<p><code>guru</code>模式中可能有帮助的是<code>whicherrs</code>。如你所知，错误只是价值观。所以它们可以被编程，因此可以代表任何类型。看看<code>guru</code>手册上说的：</p>
<blockquote>
<p>whichers模式报告可能出现在类型error值中的一组可能的常量、全局变量和具体类型。在处理错误时，这些信息可能很有用，以确保所有重要的案件都得到处理。</p>
</blockquote>
<p>那么我们如何使用它呢？很简单。我们仍然使用相同的<code>main.go</code>文件。将光标放在从<code>http.ListenAndServe</code>返回的<code>err</code>标识符的顶部。调用<code>:GoWhicherrs</code>，您将看到以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.go|12 col 6| this error may contain these constants:</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;syscall&#x2F;zerrors_darwin_amd64.go|1171 col 2| syscall.EINVAL</span><br><span class="line">main.go|12 col 6| this error may contain these dynamic types:</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;syscall&#x2F;syscall_unix.go|100 col 6| syscall.Errno</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;net.go|380 col 6| *net.OpError</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到<code>err</code>值可能是<code>syscall.EINVAL</code>常量，也可能是动态类型<code>syscall.Errno</code>或<code>*net.OpError</code>。如您所见，这在实现定制逻辑以不同方式处理错误时非常有用。注意，这个查询需要设置guru<code>scope</code>。稍后我们将介绍<code>scope</code>是什么，以及如何动态地更改它。</p>
<p>让我们继续使用相同的<code>main.go</code>文件。Go以其并发原语（如channels）而闻名。跟踪值如何在通道之间发送有时会很困难。为了更好地理解它，我们有<code>peers</code>模式<code>guru</code>。此查询显示通道操作数上可能的发送/接收集（发送或接收操作）。</p>
<p>将光标移到以下表达式并选择整行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打电话给<code>:GoChannelPeers</code>。您将看到一个包含以下内容的位置列表窗口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main.go|19 col 6| This channel of type chan&lt;- int may be:</span><br><span class="line">main.go|10 col 11| allocated here</span><br><span class="line">main.go|19 col 6| sent to, here</span><br><span class="line">main.go|27 col 53| received from, here</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如您所见，您可以看到通道的分配，它从何处发送和接收。因为这使用指针分析，所以必须定义一个范围。</p>
<p>让我们看看函数调用和目标是如何相关的。这次创建以下文件。<code>main.go</code>的内容应为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com&#x2F;fatih&#x2F;vim-go-tutorial&#x2F;example&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	Hello(example.GopherCon)</span><br><span class="line">	Hello(example.Kenya)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Hello(fn func() string) &#123;</span><br><span class="line">	fmt.Println(&quot;Hello &quot; + fn())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件应该在<code>example/example.go</code>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package example</span><br><span class="line"></span><br><span class="line">func GopherCon() string &#123;</span><br><span class="line">	return &quot;GopherCon&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Kenya() string &#123;</span><br><span class="line">	return &quot;Kenya&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以跳转到<code>main.go</code>中的<code>Hello</code>函数，并将光标放在名为<code>fn()</code>的函数调用的顶部。执行<code>:GoCallees</code>。此命令显示所选函数调用的可能调用目标。如您所见，它将向我们展示<code>example</code>函数中的函数声明。这些函数是被调用者，因为它们是由名为<code>fn()</code>的函数调用调用的。</p>
<p>再次跳回<code>main.go</code>，这次将光标放在函数声明<code>Hello()</code>上。如果我们想看到这个函数的调用者呢？执行<code>:GoCallers</code>。</p>
<p>您应该看到输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.go| 10 col 7 static function call from github.com&#x2F;fatih&#x2F;vim-go-tutorial.Main</span><br><span class="line">main.go| 11 col 7 static function call from github.com&#x2F;fatih&#x2F;vim-go-tutorial.Main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后还有<code>callstack</code>模式，它显示从调用图根到包含选择的函数的任意路径。</p>
<p>将光标放回<code>Hello()</code>函数内的<code>fn()</code>函数调用。选择函数并调用<code>:GoCallstack</code>。输出应如下（简化形式）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.go| 15 col 26 Found a call path from root to (...)Hello</span><br><span class="line">main.go| 14 col 5 (...)Hello</span><br><span class="line">main.go| 10 col 7 (...)main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它从<code>15</code>行开始，然后到<code>14</code>行，然后在<code>10</code>行结束。这是从根（从<code>main()</code>开始）到我们选择的函数（在我们的例子中是<code>fn()</code>）的图</p>
<p>对于大多数<code>guru</code>命令，您不需要定义任何范围。什么是<code>scope</code>？以下摘录直接摘自<code>guru</code>手册：</p>
<blockquote>
<p>指针分析范围：有些查询涉及指针分析，这是一种回答“这个指针可能指向什么”形式的问题的技术？”. 对工作区中的所有包运行指针分析通常开销太大，因此这些查询需要一个称为scope的附加配置参数，它决定要分析的包集。将作用域设置为当前正在使用的应用程序（或applications—a客户机和服务器的集合）。指针分析是whole-program分析，因此范围内唯一重要的包是主包和测试包。</p>
<p>作用域通常被指定为comma-separated包集，或者像github.com/my/dir/…这样的通配符子树；请参阅编辑器的特定文档，了解如何设置和更改范围。</p>
</blockquote>
<p><code>vim-go</code>自动尝试智能化，并为您将当前包导入路径设置为<code>scope</code>。如果命令需要一个作用域，那么大部分都可以覆盖。大多数情况下，这已经足够了，但是对于某些查询，您可能需要更改范围设置。为了便于动态更改<code>scope</code>，请使用一个名为<code>:GoGuruScope</code>的特定设置</p>
<p>如果您调用它，它将返回一个错误：<code>guru scope is not set</code>。让我们显式地将其更改为`github.com/fatih/vim-go-tutorial“范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoGuruScope github.com&#x2F;fatih&#x2F;vim-go-tutorial</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您应该看到以下消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guru scope changed to: github.com&#x2F;fatih&#x2F;vim-go-tutorial</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不带任何参数运行<code>:GoGuruScope</code>，它将输出以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current guru scope: github.com&#x2F;fatih&#x2F;vim-go-tutorial</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要选择整个<code>GOPATH</code>，可以使用<code>...</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoGuruScope ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您还可以定义多个包和子目录。以下示例选择<code>github.com</code>和<code>golang.org/x/tools</code>包下的所有包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoGuruScope github.com&#x2F;... golang.org&#x2F;x&#x2F;tools</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您可以通过在包前面加上<code>-</code>（负号）来排除包。以下示例选择<code>encoding</code>下而不是<code>encoding/xml</code>下的所有包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoGuruScope encoding&#x2F;... -encoding&#x2F;xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要清除范围，只需传递一个空字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoGuruScope &quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您正在一个项目中工作，您必须将范围始终设置为相同的值，并且您不希望每次启动Vim时都调用<code>:GoGuruScope</code>，那么您还可以通过向<code>vimrc</code>添加一个设置来定义一个永久作用域。该值必须是字符串类型的列表。以下是上述命令中的一些示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g:go_guru_scope &#x3D; [&quot;github.com&#x2F;fatih&#x2F;vim-go-tutorial&quot;]</span><br><span class="line">let g:go_guru_scope &#x3D; [&quot;...&quot;]</span><br><span class="line">let g:go_guru_scope &#x3D; [&quot;github.com&#x2F;...&quot;, &quot;golang.org&#x2F;x&#x2F;tools&quot;]</span><br><span class="line">let g:go_guru_scope &#x3D; [&quot;encoding&#x2F;...&quot;, &quot;-encoding&#x2F;xml&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，<code>vim-go</code>会在使用<code>:GoGuruScope</code>时自动完成软件包。所以当你试图写<code>github.com/fatih/vim-go-tutorial</code>只需输入<code>gi</code>并点击<code>tab</code>，你会发现它会扩展到<code>github.com</code></p>
<p>另一个需要注意的设置是构建标记（也称为构建约束）。例如，下面是您在Go源代码中放置的构建标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; +build linux darwin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时源代码中可能有自定义标记，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; +build mycustomtag</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这种情况下，guru将失败，因为底层的<code>go/build</code>包将无法构建该包。因此，所有<code>guru</code>相关的命令都将失败（即使<code>:GoDef</code>在使用<code>guru</code>时也是如此）。幸运的是，<code>guru</code>有一个<code>-tags</code>标志，允许我们传递自定义标记。为了方便<code>vim-go</code>用户，我们有一个<code>:GoBuildTags</code></p>
<p>对于示例，只需调用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoBuildTags mycustomtag</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这将把这个标记传递给<code>guru</code>，从现在起它将按预期工作。就像<code>:GoGuruScope</code>，你可以用以下方法清除它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoBuildTags &quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，如果您愿意，可以使用以下设置使其永久化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_build_tags &#x3D; &quot;mycustomtag&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Refactor-it"><a href="#Refactor-it" class="headerlink" title="Refactor it"></a>Refactor it</h1><h3 id="Rename-identifiers"><a href="#Rename-identifiers" class="headerlink" title="Rename identifiers"></a>Rename identifiers</h3><p>重命名标识符是最常见的任务之一。但这也是一件需要小心处理的事情，以免破坏其他包裹。同样，仅仅使用<code>sed</code>这样的工具有时是没有用的，因为您希望能够感知AST的重命名，所以它只应该重命名属于AST的标识符（它不应该重命名其他非Go文件中的标识符，比如构建脚本）</p>
<p>有一个为您重命名的工具，名为<code>gorename</code>。<code>vim-go</code>使用<code>:GoRename</code>命令在引擎盖下使用<code>gorename</code>。让我们将<code>main.go</code>更改为以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Server struct &#123;</span><br><span class="line">	name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s :&#x3D; Server&#123;name: &quot;Alper&quot;&#125;</span><br><span class="line">	fmt.Println(s.name) &#x2F;&#x2F; print the server name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func name() string &#123;</span><br><span class="line">	return &quot;Zeynep&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将光标放在<code>Server</code>结构中<code>name</code>字段的顶部，然后调用<code>:GoRename bar</code>。您将看到所有<code>name</code>引用都被重命名为<code>bar</code>。最终内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Server struct &#123;</span><br><span class="line">	bar string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s :&#x3D; Server&#123;bar: &quot;Alper&quot;&#125;</span><br><span class="line">	fmt.Println(s.bar) &#x2F;&#x2F; print the server name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func name() string &#123;</span><br><span class="line">	return &quot;Zeynep&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如您所见，只有必要的标识符被重命名，但是函数<code>name</code>或注释中的字符串没有被重命名。更好的是<code>:GoRename</code>搜索<code>GOPATH</code>下的所有包，并重命名依赖于该标识符的所有标识符。这是一个非常强大的工具。</p>
<h3 id="Extract-function"><a href="#Extract-function" class="headerlink" title="Extract function"></a>Extract function</h3><p>让我们来看另一个例子。将<code>main.go</code>文件更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	msg :&#x3D; &quot;Greetings\nfrom\nTurkey\n&quot;</span><br><span class="line"></span><br><span class="line">	var count int</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(msg); i++ &#123;</span><br><span class="line">		if msg[i] &#x3D;&#x3D; &#39;\n&#39; &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个基本示例，它只计算<code>msg</code>变量中的换行数。如果您运行它，您将看到它输出<code>3</code>。</p>
<p>假设我们想在其他地方重用换行计数逻辑。让我们重构它。在这些情况下，大师可以用<code>freevars</code>模式帮助我们。<code>freevars</code>模式显示在给定选择中被引用但未定义的变量。</p>
<p>让我们选择<code>visual</code>模式下的片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var count int</span><br><span class="line">for i :&#x3D; 0; i &lt; len(msg); i++ &#123;</span><br><span class="line">	if msg[i] &#x3D;&#x3D; &#39;\n&#39; &#123;</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择后，请致电<code>:GoFreevars</code>。它应该是<code>:&#39;&lt;,&#39;&gt;GoFreevars</code>的形式。结果又是一个快速修复列表，它包含了所有自由变量的变量。在我们的例子中，它是一个单一变量，结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var msg string</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么这有多有用呢？这一小块信息足以将其重构为一个独立的函数。创建包含以下内容的新函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func countLines(msg string) int &#123;</span><br><span class="line">	var count int</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(msg); i++ &#123;</span><br><span class="line">		if msg[i] &#x3D;&#x3D; &#39;\n&#39; &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到内容是我们先前选择的代码。函数的输入是<code>:GoFreevars</code>，自由变量的结果。我们只决定归还什么（如果有的话）。在我们的情况下，我们返回计数。我们的<code>main.go</code>将采用以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	msg :&#x3D; &quot;Greetings\nfrom\nTurkey\n&quot;</span><br><span class="line"></span><br><span class="line">	count :&#x3D; countLines(msg)</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func countLines(msg string) int &#123;</span><br><span class="line">	var count int</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(msg); i++ &#123;</span><br><span class="line">		if msg[i] &#x3D;&#x3D; &#39;\n&#39; &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是重构一段代码的方法。<code>:GoFreevars</code>也可以用来理解代码的复杂性。只需运行它，看看有多少变量与之相关。</p>
<h1 id="Generate-it"><a href="#Generate-it" class="headerlink" title="Generate it"></a>Generate it</h1><p>代码生成是一个热门话题。因为有很棒的std libs，比如go/ast、go/parser、go/printer等。。围棋的优势在于能够轻松地创造出伟大的发电机。</p>
<p>首先我们有一个<code>:GoGenerate</code>命令，它在引擎盖下调用<code>go generate</code>。它就像<code>:GoBuild</code>，<code>:GoTest</code>，等等。。如果有任何错误，它也会显示它们，以便您可以轻松地修复它。</p>
<h3 id="实现接口的方法存根"><a href="#实现接口的方法存根" class="headerlink" title="实现接口的方法存根"></a>实现接口的方法存根</h3><p>接口对组合非常有用。它们使代码更容易处理。创建测试也更容易，因为您可以模拟接受接口类型的函数，该接口类型具有实现测试方法的类型。</p>
<p><code>vim-go</code>支持工具impl。<code>impl</code>生成实现给定接口的方法存根。让我们将<code>main.go</code>的内容更改为以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type T struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将光标放在<code>T</code>的顶部，然后键入<code>:GoImpl</code>。系统将提示您编写接口。输入<code>io.ReadWriteCloser</code>，然后按enter键。您将看到内容更改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type T struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (t *T) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">	panic(&quot;not implemented&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *T) Write(p []byte) (n int, err error) &#123;</span><br><span class="line">	panic(&quot;not implemented&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *T) Close() error &#123;</span><br><span class="line">	panic(&quot;not implemented&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你看那真是太好了。当你在一个类型上面时，你也可以只输入<code>:GoImpl io.ReadWriteCloser</code>，它也会这样做。</p>
<p>但不需要将光标放在类型的顶部。你可以从任何地方调用它。例如，执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:GoImpl b *B fmt.Stringer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>您将看到将创建以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (b *B) String() string &#123;</span><br><span class="line">	panic(&quot;not implemented&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如您所见，这是非常有帮助的，特别是当您有一个带有大型方法集的大型接口时。您可以很容易地生成它，因为它使用<code>panic()</code>，所以编译时没有任何问题。只要把必要的部分填好就行了。</p>
<h1 id="Share-it"><a href="#Share-it" class="headerlink" title="Share it"></a>Share it</h1><p><code>vim-go</code>还具有通过<a target="_blank" rel="noopener" href="https://play.golang.org/%E4%B8%8E%E4%BB%96%E4%BA%BA%E8%BD%BB%E6%9D%BE%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%82%E6%AD%A3%E5%A6%82%E4%BD%A0%E6%89%80%E7%9F%A5%EF%BC%8C%E5%9B%B4%E6%A3%8B%E5%9C%BA%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%86%E4%BA%AB%E5%B0%8F%E7%89%87%E6%AE%B5%E3%80%81%E7%BB%83%E4%B9%A0%E5%92%8C/%E6%88%96%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7%E7%9A%84%E5%AE%8C%E7%BE%8E%E5%9C%BA%E6%89%80%E3%80%82%E6%9C%89%E6%97%B6%E5%80%99%E4%BD%A0%E5%9C%A8%E7%8E%A9%E5%BC%84%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95%EF%BC%8C%E6%83%B3%E5%92%8C%E5%88%AB%E4%BA%BA%E5%88%86%E4%BA%AB%E3%80%82%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%AE%BF%E9%97%AEplay.golang.org%EF%BC%8C%E7%84%B6%E5%90%8E%E7%B2%98%E8%B4%B4%E5%AE%83%E3%80%82%60vim-go%60%E4%BD%BF%E7%94%A8%60:GoPlay%60%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E4%BD%BF%E6%89%80%E6%9C%89%E8%BF%99%E4%BA%9B%E9%83%BD%E5%8F%98%E5%BE%97%E6%9B%B4%E5%A5%BD%E3%80%82">https://play.golang.org/与他人轻松共享代码的功能。正如你所知，围棋场是一个分享小片段、练习和/或提示和技巧的完美场所。有时候你在玩弄一个想法，想和别人分享。复制代码并访问play.golang.org，然后粘贴它。`vim-go`使用`:GoPlay`命令可以使所有这些都变得更好。</a></p>
<p>首先，让我们用以下简单代码更改<code>main.go</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;vim-go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在调用<code>:GoPlay</code>，然后按enter键。您将看到<code>vim-go</code>自动上载了源代码<code>:GoPlay</code>，并且还打开了一个显示它的浏览器选项卡。但还有更多。代码段链接也会自动复制到剪贴板。只需将链接粘贴到某个地方。你会看到链接与正在播放的内容相同play.golang.org.</p>
<p><code>:GoPlay</code>也接受一个范围。您可以选择一段代码并调用<code>:GoPlay</code>。它只会上传所选的部分。</p>
<p>有两个设置可以调整<code>:GoPlay</code>的行为。如果您不喜欢<code>vim-go</code>为您打开一个浏览器选项卡，您可以使用以下命令禁用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_play_open_browser &#x3D; 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其次，如果您的浏览器被错误检测到（我们使用的是<code>open</code>或<code>xdg-open</code>），您可以通过以下方式手动设置浏览器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:go_play_browser_command &#x3D; &quot;chrome&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HTML-template"><a href="#HTML-template" class="headerlink" title="HTML template"></a>HTML template</h1><p>默认情况下，<code>.tmpl</code>文件启用了gohtml模板的语法高亮显示。如果要为另一个文件类型启用它，请将以下设置添加到<code>.vimrc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">au BufRead,BufNewFile *.gohtml set filetype&#x3D;gohtmltmpl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h1><p>本教程是我在业余时间创作的。如果你喜欢并愿意捐款，你现在可以成为一个完全的支持者，成为一个赞助人！</p>
<p>作为一个用户，你使vim-go成长和成熟，帮助我投资于错误修复、新文档，并改进当前和未来的功能。它是完全可选的，只是支持vim-go’s正在进行的开发的一种直接方法。谢谢！</p>
<p><a href="javascript:void(0);">https://www.patreon.com/fatih</a></p>
<h2 id="TODO-Commands"><a href="#TODO-Commands" class="headerlink" title="TODO Commands"></a>TODO Commands</h2><ul>
<li>:GoPath</li>
<li>:AsmFmt</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-05T10:43:04.000Z" title="2022/1/5 18:43:04">2022-01-05</time>发表</span><span class="level-item"><time dateTime="2022-01-05T10:43:04.000Z" title="2022/1/5 18:43:04">2022-01-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/">重剑无锋</a><span> / </span><a class="link-muted" href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></span><span class="level-item">1 分钟读完 (大约126个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/05/VIM-GO%E5%AE%89%E8%A3%85/">VimGo 安装</a></h1><div class="content"><p>由于众所周知的原因, “go get” &amp; “:GoInstallBinaries” 无法正常使用,经过多方查询.找到当下能用的方法</p>
<ol>
<li>set proxy</li>
</ol>
<ul>
<li>通过 <code>export GO111MODULE=on</code> 开启 MODULE</li>
<li>export GOPROXY=<a target="_blank" rel="noopener" href="https://goproxy.io/">https://goproxy.io</a><br>七牛也出了个国内代理 <a target="_blank" rel="noopener" href="https://github.com/goproxy/goproxy.cn">goproxy.cn</a> 方便国内用户更快的访问不能访问的包</li>
</ul>
<ol start="2">
<li><p>在VIM下运行 GoInstallBinaries</p>
</li>
<li><p>弹出来的错误列表中挨个复制,并使用 go install 安装.</p>
</li>
</ol>
<p>参考资料:<br><a target="_blank" rel="noopener" href="https://shockerli.net/post/go-get-golang-org-x-solution/">https://shockerli.net/post/go-get-golang-org-x-solution/</a></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/myhead.png" alt="孙起"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">孙起</p><p class="is-size-6 is-block">一往无前，生生不息。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yoyolikescici" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yoyolikescici"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/profile.php?id=100014754032705"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/yoyolikescici"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:yoyolikescici@live.cn"><i class="fas fa-envelope"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://space.bilibili.com/6861244" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BCNF/"><span class="tag">BCNF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO/"><span class="tag">GO</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NAS/"><span class="tag">NAS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SwiftUI/"><span class="tag">SwiftUI</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIM/"><span class="tag">VIM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zsh/"><span class="tag">zsh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%8B%E8%BD%BD/"><span class="tag">下载</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%A6%E5%8D%95/"><span class="tag">书单</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%94%9F/"><span class="tag">人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%A9%E5%85%B6%E5%99%A8/"><span class="tag">利其器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9E%E5%BF%86/"><span class="tag">回忆</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"><span class="tag">环境安装</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8C%83%E5%BC%8F/"><span class="tag">范式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">计算机学习笔记</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%B0%E5%BD%95/"><span class="tag">记录</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95/"><span class="tag">读书摘录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/"><span class="level-start"><span class="level-item">九阴真经</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BD%92%E6%9D%A5%E5%B0%91%E5%B9%B4/"><span class="level-start"><span class="level-item">归来少年</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BD%A2%E5%BD%B1%E5%B0%98%E5%AF%B0/"><span class="level-start"><span class="level-item">形影尘寰</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/"><span class="level-start"><span class="level-item">重剑无锋</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">环境配置</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/"><span class="level-start"><span class="level-item">闲情雅致</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%98%85%E5%B0%BD%E5%8D%83%E5%B8%86/"><span class="level-start"><span class="level-item">阅尽千帆</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-09T09:16:12.659Z">2022-09-09</time></p><p class="title"><a href="/2022/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/">数据库范式</a></p><p class="categories"><a href="/categories/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/">九阴真经</a> / <a href="/categories/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-09T09:20:21.635Z">2022-02-09</time></p><p class="title"><a href="/2022/02/09/Tutorial%20for%20vim-go/">Tutorial for vim-go - 转载</a></p><p class="categories"><a href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/">重剑无锋</a> / <a href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-25T16:00:00.000Z">2022-01-26</time></p><p class="title"><a href="/2022/01/26/iterm2%20+%20zsh%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">iterm2 + zsh 环境配置</a></p><p class="categories"><a href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/">重剑无锋</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-05T10:43:04.000Z">2022-01-05</time></p><p class="title"><a href="/2022/01/05/VIM-GO%E5%AE%89%E8%A3%85/">VimGo 安装</a></p><p class="categories"><a href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/">重剑无锋</a> / <a href="/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-31T16:00:00.000Z">2022-01-01</time></p><p class="title"><a href="/2022/01/01/2022%20%E5%BD%B1%E5%8D%95/">2022影单</a></p><p class="categories"><a href="/categories/%E9%98%85%E5%B0%BD%E5%8D%83%E5%B8%86/">阅尽千帆</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/one.png" alt="Risen Sun&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 孙起</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="备案号" href="https://beian.miit.gov.cn/"><i class="皖ICP备18007176号-2"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>