{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2021影单","text":"《大江东去》2021年2月22日 大江东去 《一往无前》2021年6月23日 《我这一辈子》老舍《文城》余华2021年12月12日","link":"/2021/01/01/2021%20%E4%B9%A6%E5%8D%95/"},{"title":"2021影单","text":"发现女巫 第二季2021年3月1日 旺达幻视2021年3月7日 大内密探零零发2021年3月10日 拆弹专家22021年3月14日 金刚川 2021年3月15日 逃学威龙 1，2，3 2021年3月21日 ～ 24 日 神奇女侠1984 2021年4月12日 小人物 nobody 2021年4月20日 除暴 Caught in Time 2021年5月20日 你好，李焕英 2021年5月22日 小舍得（电视剧） 2021年5月22日 第一滴血 1982 2021年5月24日 第一滴血2 1985 2021年5月27日 第一滴血3 1988 2021年5月29日 第一滴血4 2008 2021年6月5日 第一滴血5：最后的血 Rambo: Last Blood 2019 2021年6月15日 黑寡妇 black widow 2021年7月10日 疯狂的赛车 2021年7月13日 控方证人 2021年8月24日 致命ID 2021年9月7日 雨人 2021年9月11日 青蛇2021年9月12日 扫黑风暴（电视剧）2021年9月25日 茶馆2021年9月26日 上帝之城2021年9月27日 卢旺达饭店2021年10月01日 失控玩家2021年10月4日 战争之王2021年10月5日 低俗小说2021年10月11日 驯龙高手2021年10月14日 被解救的姜戈2021年10月16日 千钧一发2021年10月17日 房间 2021年10月21日 金蝉脱壳 2021年10月26日 小鬼当家 2021年11月01日 小鬼当家2 2021年11月02日 贫民窟的百万富翁 2021年11月10日 尚气与十环传奇 2021年11月11日 The Mandalorian Season 1 曼达洛人1 （电视剧） 2021年11月17日 The Mandalorian Season 2 曼达洛人2 （电视剧） 2021年11月20日 毒液2 Venom: Let There be Carnage 2021年12月14日 西西里的美丽传说 2021年12月19日 釜山行 2021年12月26日 手机 2021年12月26日 史密斯夫妇 2021年12月28日 对手（电视剧）年终~","link":"/2021/04/04/2021%20%E5%BD%B1%E5%8D%95/"},{"title":"2022影单","text":"永恒族2022年1月15日 05:58:23 小敏家 电视剧2022年1月19日 15:22:38 山海情 电视剧2022年1月26日 15:22:38 乔家的儿女 电视剧2022年2月10日 权力的游戏 第一季2022年2月17日 权力的游戏 第二季2022年2月28日 权力的游戏 第三季2022年3月7日 权力的游戏 第四季2022年3月11日 权力的游戏 第五季2022年3月13日 权力的游戏 第六季2022年3月15日 权力的游戏 第七季2022年3月17日 权力的游戏 第八季2022年3月18日 蜘蛛侠 · 英雄无归2022年3月23日 第九区2022年3月25日 2001太空漫游2022年3月27日 遗落战境 Oblivion2022年3月28日 波巴菲特之书 第一季2022年4月2日 人世间2022年4月30日 康熙王朝2022年5月30日 阳光姐妹淘2022年6月2日 大红灯笼高高挂2022年6月12日 对决（电视剧）2022年6月20日 奇异博士2:疯狂多元宇宙2022年6月24日 菊次郎的夏天2022年7月11日 扬名立万-一部电影的诞生2022年7月16日 南海十三郎2022年7月20日 寻秦记2022年7月27日 过年2022年8月1日 误杀瞒天记2022年8月4日 007之诺博士2022年8月6日 射雕英雄传2017版2022年8月13日 隐入尘烟2022年08月18日 欢乐颂2022年09月01日 雷神4:爱与雷霆2022年09月11日 大清盐商（电视剧）2022年11月20日 独行月球2022年11月25日 哥，你好2022年11月26日 平凡英雄2022年12月4日 大清盐商2022年12月","link":"/2022/01/01/2022%20%E5%BD%B1%E5%8D%95/"},{"title":"MacOS_VIM+LaTeX","text":"下载MacTexhttp://tug.org/mactex/ 下载skimhttps://sourceforge.net/projects/skim-app/files/latest/download 在VIM中安装插件 12Plug 'lervag/vimtex'Plug 'neoclide/coc.nvim', {'branch': 'release'} 在 Neovim 中执行 :CocInstall coc-vimtex 即可。 自动补全 基础配置 12345678910111213141516171819202122232425262728293031let g:tex\\_flavor = 'latex'let g:vimtex\\_quickfix\\_mode = 0#自动同步let g:vimtex_view_general_viewer\\ = '/Applications/Skim.app/Contents/SharedSupport/displayline'let g:vimtex_view_general_options = '-r @line @pdf @tex'&quot; This adds a callback hook that updates Skim after compilationlet g:vimtex_compiler_callback_hooks = ['UpdateSkim']function! UpdateSkim(status)if !a:status | return | endiflet l:out = b:vimtex.out()let l:tex = expand('%:p')let l:cmd = [g:vimtex_view_general_viewer, '-r']if !empty(system('pgrep Skim'))call extend(l:cmd, ['-g'])endifif has('nvim')call jobstart(l:cmd + [line('.'), l:out, l:tex])elseif has('job')call job_start(l:cmd + [line('.'), l:out, l:tex])elsecall system(join(l:cmd + [line('.'), shellescape(l:out), shellescape(l:tex)], ' '))endifendfunction 这样配置后，我们就可以通过 vimtex 默认的 \\lv 快捷键（在按住 \\ 的时候，连续点击 l 和 v）来正向同步当前 Neovim 光标位置到 PDF 预览位置，也可以通过「Ctrl + 点击 PDF 预览相应位置」来反向同步 Neovim 光标位置了。 快捷键说明 \\ll：使用默认编译器（latexmk）开始监听 .tex 文件的变化，编译 LaTeX 项目并打开 PDF 预览界面； \\lk 或第二次 \\ll：停止编译器监听文件变动，停止编译； \\lv：正向从 Neovim 光标位置同步 PDF 显示区域； \\lc：清理编译生成的中间文件； 快速跳转至下一个或上一个 section 章节：[[、]]、][、[]； 删除包含当前内容的环境标签：dse (Delete surrounding environment)； 更换包含当前内容的环境标签：cse (Change surrounding environment)； 更换有 * 和无 * 的环境标签（比如将 equation* 更换为 equation、将 figure* 更换为 figure 等）tse (Toggle starred environment)： …… 12345678910111213141516171819202122232425262728293031323334353637中文模板\\\\documentclass\\[12pt\\]{article}\\\\usepackage{CJK}\\\\usepackage{geometry}\\\\geometry{a4paper,left=1cm,right=1cm,top=1cm,bottom=1cm}\\\\begin{CJK}{UTF8}{gkai}%设定新的字体快捷命令\\\\title{题目}\\\\author{作者}\\\\begin{document}\\\\maketitle\\\\section{小标题}\\\\subsection{小小标题}内容参考文献~\\\\cite{lecun2015deep}\\\\bibliographystyle{plain}\\\\bibliography{refer}\\\\end{CJK}\\\\end{document} 参考文献：https://sspai.com/post/64080https://zhuanlan.zhihu.com/p/35498361https://github.com/limberc/MacTeX-zh-support-template/blob/master/main.tex","link":"/2021/06/12/MacOS_VIM+LaTeX/"},{"title":"JavaScript高级编程","text":"什么是JavaScript1.2 JavaScript实现$$完整的JavaScript实现 \\left { \\begin{matrix} ECMAScript(核心) \\DOM(文档对象模型) \\BOM(浏览器对象模型) \\end{matrix} \\right. $$ ECMAScript: 由ECMA-262定义并提供核心功能 DOM:提供与网页内容 交互的方法和接口 BOM:提供与浏览器 交互的方法和接口. 1.2.2 DOMDocument Object Model 是一个API,用于在HTML中使用扩展的XML.DOM将整个页面抽象为一组分层节点,HTML或者XML页面的每个组成部分都是一种节点,包含不同的数据. 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello World! &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 1234567graph LRA[html] --&gt; B[head] B --&gt; C[title] C --&gt; D[Sample Page]A --&gt; E[body] E --&gt; G[p] G --&gt; H[Hello World!] DOM 通过创建表示文档的树,让开发者可以随心所欲地控制网页的内容和结构.使用DOM API,可以轻松地删除、添加、替换、修改节点. HTML中的JavaScript2.1 &lt; script &gt;元素八个属性: asyn 可选,表示应该立即开始下载脚本,但不能阻止其他页面动作.只针对外部脚本文件有效. charset crossorigin 可选,配置相关请求的CORS(跨资源共享)设置,默认不使用CORS. =“anonymous”请求不必设置凭据标志. =“use-credentials”设置凭据标志. defer 可选.表示脚本可以延迟到文档完全被解析和现实之后再执行.只针对外部脚本文件有效. integrity 可选.允许比对接收到的资源和指定的加密签名以验证子资源完整性(SRI, Subresource Intergrity).如果接收到的资源的资源的签名与这个属性指定的签名不匹配,则页面会报错,脚本不会执行.可以用于确保CDN不会提供恶意内容. language (废弃) src 可选,表示包含要执行的代码的外部文件. type 可选,代替language,表示代码块中脚本语言的内容类型.","link":"/2021/12/14/JavaScript%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"title":"PT站点升级相关要求","text":"Power User Elite User Crazy User Insane User Veteran User Extreme User Ultimate User Nexus User 学校 50G4周2.04w做种积分 100G8周2.58w做种积分 300G15周3.015w做种积分 500G25周3.525w做种积分 1TB40周4.040w做种积分 2TB60周4.560w做种积分 5TB80周5.080做种积分 10TB100周5.5100w做种积分 阿童木海带葡萄u2 50G4周0.95 120G8周1.55 300G15周2.05 500G25周2.55 750G40周3.05 1TB60周3.55 1.5TB80周4.05 3TB100周4.55 备胎（除分享率外同上）欧神1pt吧（类似）老师 1.05 1.55 2.05 2.55 3.05 3.55 4.05 4.55 猫站（周数有所不同） 5 10 15 25 30 35 40 45 Area 50G4周1.05 120G8周3 300G10周3.5 750G12周4 1TB20周4.5 2TB25周5 5TB30周5.5 10TB40周6 铂金家 200G4周1.02w分 350G8周1.15w分 500G15周1.220w分 1TB25周1.340w分 2TB40周1.560w分 3TB60周1.580w分 4TB80周1.7100w分 6TB100周1.8120w分 馒头 200G4周2 400G8周3 500G12周4 800G16周5 1TB20周6 2TB24周7 2.5TB28周8 3TB32周9 52pt 50G4周1.05 120G8周1.55 300G15周2.05 1.5TB25周2.55 2.5TB40周3.05 3.0TB60周3.55 4.5TB80周4.05 5TB100周4.55 我堡柠檬 100G5周2 350G10周2.5 500G15周3 1TB20周3.5 2TB25周4 4TB30周4.5 6TB40周5 8TB52周5.5 天空 200G5周2 500G10周2.5 1TB15周3 2TB20周3.5 4TB25周4 6TB30周4.5 8TB45周5 10TB65周5.5 杜比 120G2周2.0 256G4周2.5 512G8周3.0 768G12周3.5 1TB16周4.0 2TB20周4.5 4TB24周5.0 8TB48周5.5 ttg 50G5周1.1 150G8周2.0 250G8周2.0 500G8周2.5 750G16周2.5 1TB24周3.0 1.5TB24周3.5 2.5TB24周4.0 3.5TB32周5.0 家园 128G5周1.64w分 256G5周1.910w分 512G10周2.318w分 768G10周2.728w分 1TB20周3.240w分 2TB20周3.754w分 4TB30周3.670w分 8TB30周4.1100w分 朋 50G5周1.03200 150G10周1.519200 300G15周2.076800 500G30周2.5256000 1TB60周3.564w 2TB90周4.0128w 3TB120周4.5192w 4TB150周5.0256w","link":"/2021/09/13/PTLevel/"},{"title":"SwiftUI页面跳转","text":"TabView 12345678910111213141516171819202122232425262728293031323334353637struct ContentView: View { @State private var selection : Tab = .home enum Tab { case home case journal case statistics case settings// case test case test2 } var body: some View { TabView(selection: $selection){ HomeView() .tabItem { Label(&quot;主页&quot;, systemImage : &quot;house&quot;) } .tag(Tab.home) ViewJournal() .tabItem { Label(&quot;流水&quot;, systemImage:&quot;newspaper&quot;) } .tag(Tab.journal) ViewStatistics() .tabItem { Label(&quot;统计&quot;, systemImage:&quot;waveform.path.ecg&quot;) } .tag(Tab.statistics) ViewSettings() .tabItem { Label(&quot;设置&quot;, systemImage:&quot;seal&quot;) } .tag(Tab.settings) } }} NavigationLink 12345678NavigationView { VStack { NavigationLink(destination: Text(&quot;点击后显示的视图内容&quot;)) { Text(&quot;可点击内容&quot;) } } .navigationBarTitle(&quot;这是顶部标题&quot;)} 123456789NavigationView { List(0..&lt;3) { i in NavigationLink( destination: Text(&quot;点击列表页后进入的页面 (i)&quot;)) { Text(&quot;列表序号 (i)&quot;) } } .navigationBarTitle(&quot;标题&quot;)} sheet向上拉起 123456789101112131415161718192021222324import SwiftUIstruct ContentView:View { var body: some View{ TestSheet() }}struct TestSheet: View { @State private var popoverIsShown = false var body: some View { Button(&quot;显示 Sheet&quot;) { self.popoverIsShown = true } .sheet(isPresented: self.$popoverIsShown) { RandomSheet(popoverIsShown: self.$popoverIsShown) } }}struct RandomSheet: View { @Binding var popoverIsShown: Bool var body: some View { Button(&quot;关闭&quot;) { self.popoverIsShown = false } }} ActionSheet 12345678910Button(&quot;显示Sheet页&quot;) { showingSheet = true//点击后改显示}.actionSheet(isPresented: $showingSheet) { ActionSheet( title: Text(&quot;你想在这个页面放点啥?弹出一个提示，还可以修改信息等操作&quot;), message: Text(&quot;如果要关闭此页只需要向下滑动或者点击下面的按钮...&quot;), buttons: [.default(Text(&quot;关闭此面&quot;))] )} popover popover是一个专用的修改器来显示弹出窗口，在iPadOS上它显示为浮动气球，而在iOS上则像一张纸一样滑到屏幕上。 要显示弹出窗口，您需要某种状态来确定该弹出窗口当前是否可见，但仅此而已–与警报和操作表不同，弹出窗口可以包含所需的任何视图。因此，只要将您需要的任何东西放在弹出窗口中，SwiftUI就会处理其余的工作。 例如，当点击一个按钮时，将显示一个弹出视图： 1234567891011121314struct ContentView: View { @State private var showingPopover = false var body: some View { Button(&quot;显示菜单&quot;) { showingPopover = true } .popover(isPresented: $showingPopover) { Text(&quot;你要的内容在这里！&quot;) .font(.headline) .padding() } }} alert1Alert(title: Text(&quot;弹出的标题!&quot;), message: Text(&quot;这是消息的内容&quot;), dismissButton: .default(Text(&quot;OK&quot;))) 参考资料：http://www.neter8.com/ios/127.html","link":"/2021/06/14/SwiftUI%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"},{"title":"VimGo 安装","text":"由于众所周知的原因, “go get” &amp; “:GoInstallBinaries” 无法正常使用,经过多方查询.找到当下能用的方法 set proxy 通过 export GO111MODULE=on 开启 MODULE export GOPROXY=https://goproxy.io七牛也出了个国内代理 goproxy.cn 方便国内用户更快的访问不能访问的包 在VIM下运行 GoInstallBinaries 弹出来的错误列表中挨个复制,并使用 go install 安装. 参考资料:https://shockerli.net/post/go-get-golang-org-x-solution/","link":"/2022/01/05/VIM-GO%E5%AE%89%E8%A3%85/"},{"title":"Tutorial for vim-go - 转载","text":"https://www.5axxw.com/wiki/content/wo6s81#alternate-files ( 如需查看英文版本，请 点击这里 ) 存档项目。无需维护。此项目不再维护，已存档。如果需要的话，你可以自由选择，做出自己的改变。更多细节请阅读我的博客文章：从我的项目中无限期休假 感谢大家的宝贵反馈和贡献。 vim-go教程。一个关于如何安装和使用vim-go的简单教程。 目录 Quick Setup Hello World Build it Cover it Edit it Alternate files 转到定义 在函数之间移动 Understand it Documentation Lookup Identifier resolution 依赖项和文件 实现接口的方法存根 Quick Setup我们将使用vim-plug来安装vim-go。请随意使用其他插件管理器。我们将创建一个最小的~/.vimrc，并在继续的过程中添加它。 首先获取并安装vim-plug和vim-go： 123curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vimgit clone https://github.com/fatih/vim-go.git ~/.vim/plugged/vim-go 使用以下内容创建~/.vimrc： 1234call plug#begin()Plug 'fatih/vim-go', { 'do': ':GoInstallBinaries' }call plug#end() 或者打开Vim并执行:GoInstallBinaries。这是一个vim-go命令，它为您安装所有vim-go依赖项。它不下载预编译的二进制文件，而是在后台调用go get，因此二进制文件都在主机中编译（这既安全又简化了安装过程，因为我们不需要为多个平台提供二进制文件）。如果您已经有一些依赖项（例如guru，goimports），请调用:GoUpdateBinaries来更新二进制文件。 在本教程中，我们所有的例子都在GOPATH/src/github.com/fatih/vim-go-tutorial/下。请确保您在该文件夹中。这将使您更容易地遵循教程。如果已经有GOPATH设置，请执行： 12go get github.com/fatih/vim-go-tutorial 或者根据需要创建文件夹。 Hello World!从终端打开main.go文件： 12vim main.go 这是一个将vim-go打印到stdout的非常基本的文件。 Run it您可以使用:GoRun %轻松运行该文件。在引擎盖下，它为当前文件调用go run。您应该看到它打印了vim-go。 对于使用:GoRun运行的整个包。 Build it将vim-go替换为Hello Gophercon。让我们编译这个文件，而不是运行它。我们有:GoBuild。如果您调用它，您应该看到以下消息： 12vim-go: [build] SUCCESS 在引擎盖下面它叫go build，但它更聪明一点。它做了一些不同的事情： 不创建二进制文件；您可以多次调用:GoBuild，而不会污染您的工作区。 它会自动cds到源包的目录中 它分析任何错误并在快速修复列表中显示它们 它自动检测GOPATH并在需要时修改它（检测诸如gb、Godeps、etc..）等项目 如果在Vim8.0.xxx或NeoVim中使用，则运行异步 Fix it让我们通过添加两个编译错误来介绍两个错误： 1234567var b = foo()func main() { fmt.Println(&quot;Hello GopherCon&quot;) a} 保存文件并再次调用:GoBuild。 这次将打开quickfix视图。要在错误之间跳转，可以使用:cnext和:cprevious。让我们修复第一个错误，保存文件并再次调用:GoBuild。您将看到quickfix列表更新了一个错误。同时删除第二个错误，保存文件并再次调用:GoBuild。现在，因为不再有错误，vim-go会自动关闭quickfix窗口。 让我们稍微改进一下。Vim有一个名为autowrite的设置，如果您调用:make，它会自动写入文件的内容。vim-go也使用此设置。打开.vimrc并添加以下内容： 12set autowrite 现在，当您调用:GoBuild时，您不必再保存文件了。如果我们重新引入这两个错误并调用:GoBuild，我们现在可以通过只调用:GoBuild来更快地迭代。 :GoBuild跳转到遇到的第一个错误。如果您不想跳转附加!（bang）符号：:GoBuild!。 在所有go命令中，例如:GoRun、:GoInstall、:GoTest、etc..，每当出现错误时，quickfix窗口总是会弹出。 vimrc improvements 您可以添加一些快捷方式，以便在快速修复列表中的错误之间切换： 1234map &lt;C-n&gt; :cnext&lt;CR&gt;map &lt;C-m&gt; :cprevious&lt;CR&gt;nnoremap &lt;leader&gt;a :cclose&lt;CR&gt; 我还使用这些快捷方式来构建和运行一个带有&lt;leader&gt;b和&lt;leader&gt;r的Go程序： 123autocmd FileType go nmap &lt;leader&gt;b &lt;Plug&gt;(go-build)autocmd FileType go nmap &lt;leader&gt;r &lt;Plug&gt;(go-run) Vim中有两种类型的错误列表。一个叫做location list，另一个叫quickfix。不幸的是，每个列表的命令是不同的。所以:cnext只适用于quickfix列表，而location lists则必须使用:lnext。vim-go中的一些命令打开一个位置列表，因为位置列表与一个窗口相关联，每个窗口都可以有一个单独的列表。这意味着您可以有多个窗口和多个位置列表，一个用于Build，一个用于Check，一个用于Tests，等等。。 但是有些人喜欢只使用quickfix。如果将以下内容添加到vimrc中，则所有列表的类型都为quickfix： 12let g:go_list_type = &quot;quickfix&quot; Test it让我们编写一个简单的函数并对该函数进行测试。添加以下内容： 1234func Bar() string { return &quot;bar&quot;} 打开一个名为main_test.go的新文件（无论您如何打开它，从Vim内部，一个单独的Vim会话，等等）。。这取决于你）。让我们使用当前缓冲区并通过:edit main_test.go从Vim打开它。 当你打开新文件时，你会注意到一些东西。文件将自动添加包声明： 12package main 这是由vim-go自动完成的。它检测到文件在一个有效的包中，因此基于包名创建了一个文件（在我们的例子中，包名是main）。如果没有文件，vim-go会自动用一个简单的主包填充内容。 使用以下代码更新测试文件： 12345678910111213package mainimport ( &quot;testing&quot;)func TestBar(t *testing.T) { result := Bar() if result != &quot;bar&quot; { t.Errorf(&quot;expecting bar, got %s&quot;, result) }} 打电话:GoTest。您将看到以下消息： 12vim-go: [test] PASS :GoTest在引擎盖下调用go test。它具有与:GoBuild相同的改进。如果有任何测试错误，将再次打开快速修复列表，您可以轻松地跳转到该列表。 另一个小的改进是您不必打开测试文件本身。你自己试试：打开main.go然后打:GoTest。您将看到测试也将为您运行。 :GoTest默认10秒后超时。这很有用，因为Vim在默认情况下不是异步的。您可以使用let g:go_test_timeout = '10s'更改超时值 我们还有两个命令，可以方便地处理测试文件。第一个是:GoTestFunc。这只测试光标下的函数。让我们将测试文件（main_test.go）的内容更改为： 123456789101112131415161718192021package mainimport ( &quot;testing&quot;)func TestFoo(t *testing.T) { t.Error(&quot;intentional error 1&quot;)}func TestBar(t *testing.T) { result := Bar() if result != &quot;bar&quot; { t.Errorf(&quot;expecting bar, got %s&quot;, result) }}func TestQuz(t *testing.T) { t.Error(&quot;intentional error 2&quot;)} 现在，当我们调用:GoTest时，一个快速修复窗口将打开，并显示两个错误。但是，如果进入TestBar函数并调用:GoTestFunc，您将看到我们的测试通过了！如果您有很多需要时间的测试，而您只想运行某些测试，那么这非常有用。 另一个test-related命令是:GoTestCompile。测试不仅需要成功地通过，而且还必须毫无问题地进行编译。:GoTestCompile编译测试文件，就像:GoBuild一样，并在出现错误时打开快速修复程序。但这并不能运行测试。这是非常有用的，如果你有一个大的测试，你要编辑很多。调用:GoTestCompile在当前测试文件中，您应该看到以下内容： 12vim-go: [test] SUCCESS vimrc improvements 与:GoBuild一样，我们可以添加一个映射，用组合键轻松调用:GoTest。在.vimrc中添加以下内容： 12autocmd FileType go nmap &lt;leader&gt;t &lt;Plug&gt;(go-test) 现在您可以通过&lt;leader&gt;t轻松测试文件 让我们简化building Go文件。首先，删除前面添加的以下映射： 12autocmd FileType go nmap &lt;leader&gt;b &lt;Plug&gt;(go-build) 我们将添加一个改进的映射。为了使任何Go文件无缝，我们可以创建一个简单的Vim函数来检查Go文件的类型，并执行:GoBuild或:GoTestCompile。下面是可以添加到.vimrc中的帮助函数： 123456789101112&quot; run :GoBuild or :GoTestCompile based on the go filefunction! s:build_go_files() let l:file = expand('%') if l:file =~# '^\\f\\+_test\\.go$' call go#test#Test(0, 1) elseif l:file =~# '^\\f\\+\\.go$' call go#cmd#Build(0) endifendfunctionautocmd FileType go nmap &lt;leader&gt;b :&lt;C-u&gt;call &lt;SID&gt;build_go_files()&lt;CR&gt; 现在只要你点击&lt;leader&gt;b，它就会生成你的Go文件，或者无缝地编译你的测试文件。 默认情况下，leader快捷方式被定义为：\\我已经将我的leader映射到,，因为我发现下面的设置更有用（将它放在.vimrc的开头）： 12let mapleader = &quot;,&quot; 因此，通过这个设置，我们可以轻松地用,b构建任何测试和非测试文件。 Cover it让我们深入到测试的世界。测试真的很重要。Go有一种非常好的方式来显示源代码的覆盖率。vim-go可以很容易地看到代码覆盖率，而不必以非常优雅的方式离开Vim。 让我们首先将main_test.go文件改回： 12345678910111213package mainimport ( &quot;testing&quot;)func TestBar(t *testing.T) { result := Bar() if result != &quot;bar&quot; { t.Errorf(&quot;expecting bar, got %s&quot;, result) }} 和main.go到 12345678910111213141516171819202122package mainfunc Bar() string { return &quot;bar&quot;}func Foo() string { return &quot;foo&quot;}func Qux(v string) string { if v == &quot;foo&quot; { return Foo() } if v == &quot;bar&quot; { return Bar() } return &quot;INVALID&quot;} 现在让我们打电话给:GoCoverage。在引擎盖下面，这叫做go test -coverprofile tempfile。它解析概要文件中的行，然后动态更改源代码的语法以反映覆盖率。如您所见，因为我们只对Bar()函数进行了测试，这是唯一一个绿色的函数。 要清除语法突出显示，可以调用:GoCoverageClear。让我们添加一个测试用例，看看覆盖率是如何变化的。将以下内容添加到main_test.go： 123456789101112func TestQuz(t *testing.T) { result := Qux(&quot;bar&quot;) if result != &quot;bar&quot; { t.Errorf(&quot;expecting bar, got %s&quot;, result) } result = Qux(&quot;qux&quot;) if result != &quot;INVALID&quot; { t.Errorf(&quot;expecting INVALID, got %s&quot;, result) }} 如果我们再次调用:GoCoverage，您将看到Quz函数现在也经过了测试，并且覆盖范围更广。再次调用:GoCoverageClear清除语法高亮显示。 因为调用:GoCoverage和:GoCoverageClear经常一起使用，所以有另一个命令可以方便地调用和清除结果。您也可以使用:GoCoverageToggle。它充当一个开关并显示覆盖范围，当再次调用时，它将清除覆盖范围。如何使用它们取决于您的工作流程。 最后，如果您不喜欢vim-go’s内部视图，也可以调用:GoCoverageBrowser。它使用go tool cover创建一个HTML页面，然后在默认浏览器中打开它。有些人更喜欢这个。 使用:GoCoverageXXX命令不会创建任何类型的临时文件，也不会污染您的工作流。所以你不必每次都处理删除不需要的文件。 vimrc improvements在.vimrc中添加以下内容： 12autocmd FileType go nmap &lt;Leader&gt;c &lt;Plug&gt;(go-coverage-toggle) 有了这个，你可以很容易地用&lt;leader&gt;c调用:GoCoverageToggle Edit itImports让我们从一个main.go文件开始： 12345678package main import &quot;fmt&quot;func main() { fmt.Println(&quot;gopher&quot; )} 让我们从我们已经知道的事情开始吧。如果我们保存文件，你会看到它会自动格式化。默认情况下，它是启用的，但是如果需要，可以使用let g:go_fmt_autosave = 0禁用它（不确定为什么要禁用：）。我们还可以选择提供:GoFmt命令，它在引擎盖下运行gofmt。 让我们用大写字母打印&quot;gopher&quot;字符串。为此，我们将使用strings包。要更改定义： 12fmt.Println(strings.ToUpper(&quot;gopher&quot;)) 当你建立它时，你会得到一个错误，当然： 12main.go|8| undefined: strings in strings.ToUpper 您将看到我们得到一个错误，因为strings包没有导入。vim-go有两个命令可以方便地操作导入声明。 我们可以很容易地去编辑文件，但是我们将使用Vim命令:GoImport。此命令将给定的包添加到导入路径。{via::GoImport strings}运行。您将看到正在添加strings包。这个命令最棒的地方是它还支持完成。所以你只需输入:GoImport s然后点击tab。 我们还需要:GoImportAs和:GoDrop来编辑导入路径。:GoImportAs与:GoImport相同，但它允许更改包名。例如:GoImportAs str strings，将使用包名str.导入strings 最后，:GoDrop可以很容易地从导入声明中删除任何导入路径。:GoDrop strings将从导入声明中删除它。 当然，操纵导入路径是2010年的事了。我们有更好的工具来处理这个案子。如果你还没听说过，那就叫goimports。goimports是gofmt的替代品。你有两种使用方法。第一种（也是推荐的）方法是告诉vim-go在保存文件时使用它： 12let g:go_fmt_command = &quot;goimports&quot; 现在每当您保存文件时，goimports将自动格式化并重写导入声明。有些人不喜欢goimports，因为它在非常大的代码基上可能很慢。在本例中，我们还有:GoImports命令（注意末尾的s）。这样，您就可以显式地调用goimports Text objects让我们展示更多编辑技巧。我们可以使用两个文本对象来更改函数。它们是if和af。if表示内部函数，它允许您选择函数外壳的内容。将main.go文件更改为： 123456789101112package mainimport &quot;fmt&quot;func main() { fmt.Println(1) fmt.Println(2) fmt.Println(3) fmt.Println(4) fmt.Println(5)} 将光标放在func关键字上，现在在normal模式下执行以下操作，然后看看会发生什么： 12dif 您将看到函数体被移除。因为我们使用了d运算符。使用u撤消更改。最棒的是，光标可以是从func关键字开始到右大括号}的任意位置。它使用引擎盖下的刀具运动。我为vim-go显式地编写了motion来支持这样的特性。它具有很强的感知能力，因此它的性能非常好。你可能会问什么？将main.go改为： 1234567891011121314package mainimport &quot;fmt&quot;func Bar() string { fmt.Println(&quot;calling bar&quot;) foo := func() string { return &quot;foo&quot; } return foo()} 以前我们使用regexp-based文本对象，这会导致问题。例如，在这个例子中，将光标放在匿名函数func关键字上，并以normal模式执行dif。您将看到只有匿名函数的主体被删除。 到目前为止，我们只使用了d运算符（delete）。但这取决于你。例如，您可以通过vif选择它，或者使用yif来拖动（复制）。 我们还有af，意思是a function。此文本对象包括整个函数声明。将main.go更改为： 1234567891011121314151617package mainimport &quot;fmt&quot;// bar returns a the string &quot;foo&quot; even though it's named as &quot;bar&quot;. It's an// example to be used with vim-go's tutorial to show the 'if' and 'af' text// objects.func bar() string { fmt.Println(&quot;calling bar&quot;) foo := func() string { return &quot;foo&quot; } return foo()} 所以这是一件伟大的事情。由于motion，我们对每个语法节点都有充分的了解。将光标放在func关键字的上方或下方或上方的任何位置（无所谓）。如果现在执行vaf，您将看到函数声明和doc注释都被选中了！例如，您可以用daf删除整个函数，您将看到注释也消失了。继续将光标放在注释的顶部，执行vif，然后执行vaf。您将看到它选择了函数体，即使光标在函数之外，或者它也选择了函数注释。 这真的很强大，这一切都要归功于我们从let g:go_textobj_include_function_doc = 1motion学到的知识。如果不希望注释成为函数声明的一部分，可以使用以下方法轻松禁用它： 12let g:go_textobj_include_function_doc = 0 如果您有兴趣了解关于motion的更多信息，请查看我写的博客文章：将Go类型视为vim中的对象 （可选问题：不看go/ast包，doc注释是否是函数声明的一部分？） 结构拆分和联接有一个很好的插件可以让你拆分或连接Go结构。它实际上不是一个Go插件，但它支持Go结构。要启用它，请将plug定义之间的plugin指令添加到vimrc中，然后在vim编辑器中执行:source ~/.vimrc并运行:PlugInstall。例子： 12345call plug#begin()Plug 'fatih/vim-go'Plug 'AndrewRadev/splitjoin.vim'call plug#end() 安装插件后，将main.go文件更改为： 123456789101112package maintype Foo struct { Name string Ports []int Enabled bool}func main() { foo := Foo{Name: &quot;gopher&quot;, Ports: []int{80, 443}, Enabled: true}} 将光标放在与结构表达式相同的行上。现在输入gS。这将split将结构表达式分成多行。你甚至可以逆转它。如果光标仍在foo变量上，请在normal模式下执行gJ。您将看到字段定义都已联接。 这不使用任何AST-aware工具，因此例如，如果您在字段顶部键入gJ，您将看到只有两个字段被联接。 SnippetsVim-go支持两个流行的snippet插件。Ultisnips和neosnippet。默认情况下，如果您安装了Ultisnips，它就可以工作了。让我们先安装ultisnips。在vimrc中的plug指令之间添加它，然后在vim编辑器中执行:source ~/.vimrc，然后运行:PlugInstall。例子： 12345call plug#begin()Plug 'fatih/vim-go'Plug 'SirVer/ultisnips'call plug#end() 有许多有用的片段。要查看完整列表，请查看我们当前的片段：https://github.com/fatih/vim-go/blob/master/gosnippets/UltiSnips/go.snippets UltiSnips和YouCompleteMe可能在[tab]按钮上发生冲突 让我展示一下我用得最多的一些片段。将main.go内容更改为： 123456789101112131415161718192021222324package mainimport &quot;encoding/json&quot;type foo struct { Message string Ports []int ServerName string}func newFoo() (*foo, error) { return &amp;foo{ Message: &quot;foo loves bar&quot;, Ports: []int{80}, ServerName: &quot;Foo&quot;, }, nil}func main() { res, err := newFoo() out, err := json.Marshal(res)} 让我们把光标放在newFoo()表达式之后。如果错误是non-nil，让我们在这里惊慌失措。在insert模式下输入errp，然后点击tab。您将看到它将被展开并将光标放在“panic（）`”函数中： 123456if err != nil { panic( ) ^ cursor position} 用err填充恐慌，然后转到json.Marshal语句。做同样的事情。 现在让我们打印变量out。由于变量打印非常流行，因此我们有几个片段： 12345fn -&gt; fmt.Println()ff -&gt; fmt.Printf()ln -&gt; log.Println()lf -&gt; log.Printf() 这里ff和lf是特殊的。它们还动态地将变量名复制到格式字符串中。你自己试试吧。将光标移到main函数的末尾，输入ff，然后点击tab。展开代码段后，可以开始键入。输入string(out)，您将看到格式字符串和变量参数都将用您键入的相同字符串填充。 这对于快速打印用于调试的变量非常方便。使用:GoRun运行文件，您将看到以下输出： 12string(out) = {&quot;Message&quot;:&quot;foo loves bar&quot;,&quot;Ports&quot;:[80],&quot;ServerName&quot;:&quot;Foo&quot;} 伟大的。现在让我展示最后一个我认为非常有用的片段。正如您在输出中看到的，字段Message和Ports以大写字符开头。为了解决这个问题，我们可以在struct字段中添加一个json标记。vim-go使添加字段标记变得非常容易。将光标移到字段中Message字符串行的末尾： 12345type foo struct { Message string . ^ put your cursor here} 在insert模式下，输入json并点击tab。您将看到它将自动扩展为有效的字段标记。字段名将自动转换为小写，并放在那里。现在应该可以看到以下内容： 1234type foo struct { Message string `json:&quot;message&quot;`} 真是太神奇了。但我们可以做得更好！继续为ServerName字段创建一个代码段扩展。您将看到它被转换为server_name。太棒了对吧？ 123456type foo struct { Message string `json:&quot;message&quot;` Ports []int ServerName string `json:&quot;server_name&quot;`} vimrc improvements 别忘了把gofmt改成goimports 12let g:go_fmt_command = &quot;goimports&quot; 当您保存文件时，gofmt在解析文件期间显示任何错误。如果有任何解析错误，它会在快速修复列表中显示它们。这是默认启用的。有些人不喜欢。要禁用它，请添加： 12let g:go_fmt_fail_silently = 1 您可以在转换时更改应应用的大小写。默认情况下，vim-go使用snake_case。但如果您愿意，也可以使用camelCase。例如，如果要将默认值更改为大小写，请使用以下设置： 12let g:go_addtags_transform = &quot;camelcase&quot; Beautify it默认情况下，我们只启用了有限的语法高亮显示。主要有两个原因。首先，人们不喜欢太多的颜色，因为它会让人分心。第二个原因是它对Vim的性能影响很大。我们需要显式地启用它。首先将以下设置添加到.vimrc： 12let g:go_highlight_types = 1 这突出显示了bar和foo： 123456type foo struct{ quz string}type bar interface{} 添加以下内容： 12let g:go_highlight_fields = 1 将突出显示下面的quz： 1234567type foo struct{ quz string}f := foo{quz:&quot;QUZ&quot;}f.quz # quz here will be highlighted 如果我们添加以下内容： 12let g:go_highlight_functions = 1 我们现在还在声明中突出显示函数和方法名。Foo和main现在将突出显示，但是Println不是因为这是一个调用： 123456func (t *T) Foo() {}func main() { fmt.Println(&quot;vim-go&quot;)} 如果还想突出显示函数和方法调用，请添加以下内容： 12let g:go_highlight_function_calls = 1 现在，Println也将突出显示： 123456func (t *T) Foo() {}func main() { fmt.Println(&quot;vim-go&quot;)} 如果添加let g:go_highlight_operators = 1，它将突出显示以下运算符，例如： 123456- + % &lt; &gt; ! &amp; | ^ * =-= += %= &lt;= &gt;= != &amp;= |= ^= *= ==&lt;&lt; &gt;&gt; &amp;^&lt;&lt;= &gt;&gt;= &amp;^=:= &amp;&amp; || &lt;- ++ -- 如果添加let g:go_highlight_extra_types = 1，以下额外类型也将突出显示： 12345bytes.(Buffer)io.(Reader|ReadSeeker|ReadWriter|ReadCloser|ReadWriteCloser|Writer|WriteCloser|Seeker)reflect.(Kind|Type|Value)unsafe.Pointer 让我们继续了解更多有用的亮点。构建标签呢？不查看go/build文档就不容易实现它。让我们首先添加以下内容：let g:go_highlight_build_constraints = 1并将main.go文件更改为： 123// build linuxpackage main 你会看到它是灰色的，所以它是无效的。将+添加到build单词并再次保存： 123// +build linuxpackage main 你知道为什么吗？如果您阅读go/build包，您将看到以下内容隐藏在文档中： … 前面只有空行和其他行注释。 让我们再次更改内容并将其保存到： 1234// +build linuxpackage main 您将看到它以有效的方式自动高亮显示它。真的很棒。如果您将linux更改为某个内容，您将看到它还检查有效的官方标记（例如darwin、race、ignore等） 另一个类似的特性是突出显示Go指令//go:generate。如果将let g:go_highlight_generate_tags = 1放入vimrc，它将突出显示使用go generate命令处理的有效指令。 我们有更多的亮点设置，这些只是一个偷窥。如需更多信息，请通过:help go-settings查看设置 vimrc improvements 有些人不喜欢标签的显示方式。默认情况下，Vim为单个选项卡显示8个空格。然而，如何在Vim中表示取决于我们。以下内容将更改为将单个选项卡显示为4个空格： 12autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4 此设置不会将选项卡展开为空格。它将用4空格显示一个选项卡。它将使用4空格来表示单个缩进。 很多人要我的配色方案。我用的是稍加修改的molokai。要启用它，请在Plug定义之间添加Plug指令： 12345call plug#begin()Plug 'fatih/vim-go'Plug 'fatih/molokai'call plug#end() 同时添加以下内容，以启用原始配色方案和256色版本的molokai： 1234let g:rehash256 = 1let g:molokai_original = 1colorscheme molokai 然后重启Vim并调用:source ~/.vimrc，然后调用:PlugInstall。这将拉插件并为您安装。安装插件后，您需要重新启动Vim。 Check it从前面的示例中，您看到我们有许多命令，当出现问题时，这些命令将显示quickfix窗口。例如，:GoBuild显示编译输出中的错误（如果有）。或者例如:GoFmt显示当前文件格式化时的解析错误。 我们有许多其他命令，允许我们调用然后收集错误、警告或建议。 例如:GoLint。在幕后，它调用golint，这是一个建议更改以使Go代码更具惯用性的命令。还有一个:GoVet，它在引擎盖下调用go vet。有许多其他工具可以检查某些东西。为了让它更简单，有人决定创建一个调用所有这些跳棋的工具。这个工具叫做gometalinter。vim-go通过命令:GoMetaLinter支持它。那么它有什么作用呢？ 如果您只是调用:GoMetaLinter来获取给定的Go源代码。默认情况下，它将同时运行go vet、golint和errcheck。gometalinter收集所有输出并将其规范化为通用格式。因此，如果您调用:GoMetaLinter，vim-go将在快速修复列表中显示所有这些跳棋的结果。然后，您可以轻松地在lint、vet和errcheck结果之间切换。此默认设置如下： 12let g:go_metalinter_enabled = ['vet', 'golint', 'errcheck'] 还有许多其他工具，您可以轻松地自定义此列表。如果您调用:GoMetaLinter，它将自动使用上面的列表。 因为:GoMetaLinter通常很快，vim-go也可以在每次保存文件时调用它（就像:GoFmt）。要启用它，您需要将以下内容添加到.vimrc: 12let g:go_metalinter_autosave = 1 最棒的是，autosave的跳棋与:GoMetaLinter不同。这很好，因为您可以自定义它，所以在保存文件时只调用快速检查程序，但如果您调用:GoMetaLinter，则调用其他检查程序。下面的设置允许您为autosave特性定制方格。 12let g:go_metalinter_autosave_enabled = ['vet', 'golint'] 如您所见，默认情况下启用vet和golint。最后，为了防止:GoMetaLinter运行太长时间，我们有一个设置，在给定的超时之后取消它。默认为5 seconds，但可以通过以下设置进行更改： 12let g:go_metalinter_deadline = &quot;5s&quot; Navigate it到目前为止，我们只跳过了main.go和main_test.go两个文件。如果在同一个目录中只有两个文件，那么切换非常容易。但是如果项目随着时间的推移变得越来越大呢？或者如果文件本身太大，以至于您很难导航它呢？ Alternate filesvim-go有几种改进导航的方法。首先让我展示一下如何在Go源代码和它的测试文件之间快速跳转。 假设您有一个foo.go及其等价的测试文件foo_test.go。如果您有前面示例中的main.go及其测试文件，您也可以打开它。打开后，只需执行以下Vim命令： 12:GoAlternate 您将看到您立即切换到main_test.go。如果您再次执行它，它将切换到main.go。:GoAlternate起到切换的作用，如果您有一个包含许多测试文件的包，则非常有用。这个想法非常类似于plugina.vim命令名。这个插件在.c和.h文件之间跳跃。在我们的例子中，:GoAlternate用于在测试和non-test文件之间切换。 转到定义最常用的特性之一是go to definition。从一开始，vim-go有一个:GoDef命令，该命令跳转到任何标识符的声明。让我们首先创建一个main.go文件来显示它的实际操作。使用以下内容创建它： 12345678910111213141516package mainimport &quot;fmt&quot;type T struct { Foo string}func main() { t := T{ Foo: &quot;foo&quot;, } fmt.Printf(&quot;t = %+v\\n&quot;, t)} 现在我们有几种跳到声明的方法。例如，如果您将光标放在T表达式的顶部，紧跟在main函数之后并调用:GoDef，它将跳转到类型声明。 如果您将光标放在t变量声明的顶部，紧跟在main函数之后并调用:GoDef，您将看到不会发生任何事情。因为没有地方可去，但是如果您向下滚动几行并将光标放在fmt.Printf()中使用的t变量并调用:GoDef，您将看到它跳转到变量声明。 :GoDef不仅适用于本地范围，而且在全局范围内（跨GOPATH）工作。例如，如果您将光标放在Printf()函数的顶部并调用:GoDef，它将直接跳转到fmt包。因为这是如此频繁地使用，vim-go也覆盖了内置的Vim快捷方式gd和ctrl-]。因此，您可以轻松地使用gd或ctrl-]来代替:GoDef 一旦我们跳转到一个声明，我们可能还想回到以前的位置。默认情况下，Vim快捷键ctrl-o会跳转到上一个光标位置。当它运行得很好时，它会很好地工作，但是如果您在Go声明之间导航，就不够好了。例如，如果您跳转到:GoDef的文件，然后向下滚动到底部，然后可能到顶部，ctrl-o也会记住这些位置。因此，如果你想在调用:GoDef时跳回上一个位置，你必须多次点击ctrl-o。这真的很烦人。 不过，我们不需要使用这个快捷方式，因为vim-go为您提供了更好的实现。有一个命令:GoDefPop正是这样做的。vim-go为使用:GoDef访问的所有位置保留一个内部堆栈列表。这意味着您可以通过:GoDefPop轻松地跳回原来的位置，即使您在文件中向下/向上滚动也可以。因为这也被使用了很多次，所以我们有一个快捷方式ctrl-t，它在引擎盖下调用:GoDefPop。所以回顾一下： 使用ctrl-]或gd跳转到本地或全局定义 使用ctrl-t跳回上一个位置 让我们继续问另一个问题，假设你跳得太远，只想回到你开始的地方？如前所述，vim-go保存通过:GoDef调用的所有位置的历史记录。有一个命令显示了所有这些，它名为:GoDefStack。如果您调用它，您将看到一个带有旧位置列表的自定义窗口。只需导航到所需的位置，然后按enter键。最后随时调用:GoDefStackClear清除堆栈列表。 在函数之间移动从前面的例子中，我们看到:GoDef如果您知道您想跳转到哪里，那么:GoDef是很好的。但是如果你不知道你的下一个目的地呢？或者你只知道一个函数的名字？ 在我们的Edit it部分中，我提到了一个名为motion的工具，它是一个专门为vim-go定制的工具。motion还有其他功能。motion解析Go包，因此对所有声明都有很好的理解。我们可以利用这个特性在声明之间跳转。有两个命令，在安装某个插件之前是不可用的。命令包括： 123:GoDecls:GoDeclsDir 首先，让我们通过安装必要的插件来启用这两个命令。这个插件叫做ctrlp。Long-timeVim用户已经安装了它。要安装它，请在plug指令之间添加以下行，然后在vim编辑器中执行:source ~/.vimrc，并调用:PlugInstall来安装它： 12Plug 'ctrlpvim/ctrlp.vim' 安装后，请使用以下main.go内容： 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;type T struct { Foo string}func main() { t := T{ Foo: &quot;foo&quot;, } fmt.Printf(&quot;t = %+v\\n&quot;, t)}func Bar() string { return &quot;bar&quot;}func BarFoo() string { return &quot;bar_foo&quot;} 以及一个main_test.go文件，其中包含以下内容： 123456789101112131415161718192021222324252627package mainimport ( &quot;testing&quot;)type files interface{}func TestBar(t *testing.T) { result := Bar() if result != &quot;bar&quot; { t.Errorf(&quot;expecting bar, got %s&quot;, result) }}func TestQuz(t *testing.T) { result := Qux(&quot;bar&quot;) if result != &quot;bar&quot; { t.Errorf(&quot;expecting bar, got %s&quot;, result) } result = Qux(&quot;qux&quot;) if result != &quot;INVALID&quot; { t.Errorf(&quot;expecting INVALID, got %s&quot;, result) }} 打开main.go并调用:GoDecls。您将看到:GoDecls为您显示了所有类型和函数声明。如果您输入ma，您将看到ctrlp为您过滤列表。如果你点击enter，它将自动跳转到它。模糊搜索功能与motion的AST功能相结合，给我们带来了一个非常简单但功能强大的特性。 例如，调用:GoDecls并写入foo。您将看到它将为您过滤BarFoo。Go解析器速度非常快，可以很好地处理包含数百个声明的大型文件。 有时仅仅在当前文件中搜索是不够的。一个Go包可以有多个文件（例如测试）。类型声明可以在一个文件中，而特定于一组功能的某些函数可以在另一个文件中。这就是:GoDeclsDir有用的地方。它解析给定文件的整个目录，并列出给定目录（但不是子目录）中文件的所有声明。 打电话:GoDeclsDir。这次您将看到它还包括来自main_test.go文件的声明。如果您输入Bar，您将看到Bar和TestBar函数。如果您只想获得所有类型和函数声明的概述，并跳转到它们，这真是太棒了。 让我们继续问一个问题。如果你只想转到下一个或上一个函数呢？如果当前函数体很长，则很可能看不到函数名。或者在当前函数和其他函数之间还有其他声明。 Vim已经有了像w表示单词或b表示向后单词的运动操作符。但是如果我们可以加上行动计划呢？例如函数声明？ vim-go提供（重写）两个运动对象在函数之间移动。这些是： 123]] -&gt; jump to next function[[ -&gt; jump to previous function 默认情况下，Vim有这些快捷方式。但这些都适用于C源代码和大括号之间的跳转。我们可以做得更好。就像我们前面的例子一样，motion是在引擎盖下用于这个操作的 打开main.go并移动到文件的顶部。在normal模式下，输入]]，然后看看会发生什么。您将看到您跳转到main()函数。另一个]]将跳转到Bar()，如果你点击[[，它将跳回main()函数。 ]]和[[也接受counts。例如，如果您再次移动到顶部并点击3]]，您将看到它将跳转到源文件中的第三个函数。接下来，因为这些都是有效的运动，你也可以对它应用操作符！ 如果您将文件移到顶部并点击d]]，您将看到它在下一个函数之前删除了任何内容。例如，一个有用的用法是输入v]]，然后再次点击]]来选择下一个函数，直到完成选择为止。 .vimrc improvements 我们可以改进它来控制它如何打开备用文件。在.vimrc中添加以下内容： 12345autocmd Filetype go command! -bang A call go#alternate#Switch(&lt;bang&gt;0, 'edit')autocmd Filetype go command! -bang AV call go#alternate#Switch(&lt;bang&gt;0, 'vsplit')autocmd Filetype go command! -bang AS call go#alternate#Switch(&lt;bang&gt;0, 'split')autocmd Filetype go command! -bang AT call go#alternate#Switch(&lt;bang&gt;0, 'tabe') 这将添加新的命令，称为:A、:AV、:AS和:AT。这里:A的工作方式与:GoAlternate相同，它用备用文件替换当前缓冲区。:AV将使用备用文件打开一个新的垂直拆分。:AS将在新的拆分视图中打开备用文件，在新选项卡中打开:AT。这些命令的效率非常高，这取决于您如何使用它们，所以我认为拥有它们很有用。 “go to definition”命令系列非常强大，但使用起来却很简单。默认情况下，它使用工具guru（以前是oracle）。guru有很好的可预测性记录。它适用于点导入、供应商化导入和许多其他non-obvious标识符。但有时对于某些查询来说，它非常慢。以前vim-go使用的是godef，它在解决查询方面非常快。在最新版本中，可以很容易地使用或切换:GoDef的底层工具。要将其更改回godef，请使用以下设置： 12let g:go_def_mode = 'godef' 当前默认情况下，:GoDecls和:GoDeclsDir显示类型和函数声明。这可以使用g:go_decls_includes设置进行自定义。默认情况下，它的形式是： 12let g:go_decls_includes = &quot;func,type&quot; 如果只想显示函数声明，请将其更改为： 12let g:go_decls_includes = &quot;func&quot; Understand it编写/编辑/更改代码通常只有在我们首先了解代码在做什么时才能做。vim-go有几种方法可以使您更容易地理解代码的全部内容。 Documentation lookup让我们从基础知识开始。Go文档非常well-written，并且高度集成到goast中。如果只编写一些注释，解析器可以轻松地解析它并与AST中的任何节点关联。所以这意味着我们可以很容易地以相反的顺序找到文档。如果您有一个AST节点，那么您可以轻松地从该节点读取它！ 我们有一个名为:GoDoc的命令，它显示与光标下标识符相关的任何文档。让我们将main.go的内容更改为： 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;vim-go&quot;) fmt.Println(sayHi()) fmt.Println(sayYoo())}// sayHi() returns the string &quot;hi&quot;func sayHi() string { return &quot;hi&quot;}func sayYoo() string { return &quot;yoo&quot;} 将光标放在Println函数的顶部，紧跟main函数，然后调用:GoDoc。您将看到它vim-go自动打开一个草稿窗口，为您显示文档： 123456789import &quot;fmt&quot;func Println(a ...interface{}) (n int, err error)Println formats using the default formats for its operands and writes tostandard output. Spaces are always added between operands and a newline isappended. It returns the number of bytes written and any write errorencountered. 它显示导入路径、函数签名，最后是标识符的doc注释。最初vim-go使用的是普通的go doc，但它有一些缺点，例如不能基于字节标识符进行解析。go doc非常适合终端使用，但是很难集成到编辑器中。幸运的是，我们有一个非常有用的工具gogetdoc，它解析并检索底层节点的AST节点，并输出相关的doc注释。 这就是:GoDoc适用于任何类型的标识符的原因。如果您将光标放在sayHi()下并调用:GoDoc，您将看到它也显示了它。如果你把它放在sayYoo()下，你会看到它只输出no documentation作为AST节点，没有doc注释。 与其他特性一样，我们重写默认的普通快捷方式K，以便它调用:GoDoc，而不是man（或其他东西）。很容易找到文档，只需在正常模式下点击K！ :GoDoc只显示给定标识符的文档。但是它不是一个文档浏览器，如果你想浏览文档，有一个third-party插件来完成它：go-explorer。在vim-go中包含了一个开放的bug。 Identifier resolution有时您想知道函数接受或返回的是什么。或者光标下的标识符是什么。像这样的问题很常见，我们有命令来回答。 使用相同的main.go文件，检查Println函数并调用:GoInfo。您将看到函数签名正在状态行中打印。这真的很好的看到它在做什么，因为你不必跳到定义和检查签名是什么。 但是每次打:GoInfo都很乏味。我们可以做一些改进来更快地调用它。一如既往，加快速度的一种方法是添加快捷方式： 12autocmd FileType go nmap &lt;Leader&gt;i &lt;Plug&gt;(go-info) 现在只需按一下&lt;leader&gt;i，就可以轻松地调用:GoInfo。但仍有改进的余地。vim-go支持在移动光标时自动显示信息。要启用它，请在.vimrc中添加以下内容： 12let g:go_auto_type_info = 1 现在，只要将光标移到有效标识符上，就会看到状态行自动更新。默认情况下，它每更新一次800ms。这是一个vim设置，可以用updatetime设置进行更改。要将其更改为100ms，请将以下内容添加到.vimrc 12set updatetime=100 Identifier highlighting有时我们只想快速看到所有匹配的标识符。例如变量、函数等。。假设您有以下Go代码： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;vim-go&quot;) err := sayHi() if err != nil { panic(err) }}// sayHi() returns the string &quot;hi&quot;func sayHi() error { fmt.Println(&quot;hi&quot;) return nil} 如果您将光标放在err上并调用:GoSameIds，您将看到所有的err变量都会高亮显示。将光标放在sayHi()函数调用上，您将看到sayHi()函数标识符都高亮显示。要清除它们，请致电:GoSameIdsClear 如果我们不必每次都手动调用它，这会更有用。vim-go可以自动突出显示匹配的标识符。在vimrc中添加以下内容： 12let g:go_auto_sameids = 1 重新启动vim之后，您将看到不再需要手动调用:GoSameIds。匹配的标识符变量现在会自动为您高亮显示。 依赖项和文件如您所知，一个包可以由多个依赖项和文件组成。即使目录中有许多文件，也只有正确包含package子句的文件才是包的一部分。 要查看组成包的文件，可以调用以下命令： 12:GoFiles 将输出（my$GOPATH设置为~/Code/Go）： 12['/Users/fatih/Code/go/src/github.com/fatih/vim-go-tutorial/main.go'] 如果你有其他文件，这些也会列出。请注意，此命令仅用于列出属于构建一部分的Go文件。将不列出测试文件。 为了显示文件的依赖关系，可以调用:GoDeps。如果你叫它，你会看到： 1234['errors', 'fmt', 'internal/race', 'io', 'math', 'os', 'reflect', 'runtime','runtime/internal/atomic', 'runtime/internal/sys', 'strconv', 'sync','sync/atomic ', 'syscall', 'time', 'unicode/utf8', 'unsafe'] Guru前一个特性是在引擎盖下使用guru工具。让我们来谈谈古鲁。那么什么是古鲁？Guru是一个用于导航和理解Go代码的编辑器集成工具。有一本用户手册显示了所有的特性：https://golang.org/s/using-guru 让我们使用手册中的相同示例来展示我们集成到vim-go中的一些功能： 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func main() { h := make(handler) go counter(h) if err := http.ListenAndServe(&quot;:8000&quot;, h); err != nil { log.Print(err) }}func counter(ch chan&lt;- int) { for n := 0; ; n++ { ch &lt;- n }}type handler chan intfunc (h handler) ServeHTTP(w http.ResponseWriter, req *http.Request) { w.Header().Set(&quot;Content-type&quot;, &quot;text/plain&quot;) fmt.Fprintf(w, &quot;%s: you are visitor #%d&quot;, req.URL, &lt;-h)} 将光标放在handler上，然后调用:GoReferrers。这将调用referrers模式guru，它查找对所选标识符的引用，扫描工作区内所有必需的包。结果将是一个位置列表。 guru的模式之一也是describe模式。它就像:GoInfo，但它更高级一些（它提供了更多信息）。例如，它显示类型的方法集（如果有）。如果选中，则显示包的声明。 让我们继续使用相同的main.go文件。将光标放在URL字段或req.URL（在ServeHTTP函数内）的顶部。打电话给:GoDescribe。您将看到一个包含以下内容的位置列表： 1234567891011121314151617181920main.go|27 col 48| reference to field URL *net/url.URL/usr/local/go/src/net/http/request.go|91 col 2| defined heremain.go|27 col 48| Methods:/usr/local/go/src/net/url/url.go|587 col 15| method (*URL) EscapedPath() string/usr/local/go/src/net/url/url.go|844 col 15| method (*URL) IsAbs() bool/usr/local/go/src/net/url/url.go|851 col 15| method (*URL) Parse(ref string) (*URL, error)/usr/local/go/src/net/url/url.go|897 col 15| method (*URL) Query() Values/usr/local/go/src/net/url/url.go|904 col 15| method (*URL) RequestURI() string/usr/local/go/src/net/url/url.go|865 col 15| method (*URL) ResolveReference(ref *URL) *URL/usr/local/go/src/net/url/url.go|662 col 15| method (*URL) String() stringmain.go|27 col 48| Fields:/usr/local/go/src/net/url/url.go|310 col 2| Scheme string/usr/local/go/src/net/url/url.go|311 col 2| Opaque string/usr/local/go/src/net/url/url.go|312 col 2| User *Userinfo/usr/local/go/src/net/url/url.go|313 col 2| Host string/usr/local/go/src/net/url/url.go|314 col 2| Path string/usr/local/go/src/net/url/url.go|315 col 2| RawPath string/usr/local/go/src/net/url/url.go|316 col 2| RawQuery string/usr/local/go/src/net/url/url.go|317 col 2| Fragment string 您将看到，我们可以看到字段的定义、方法集和URL结构的字段。这是一个非常有用的命令，如果您需要它并想理解周围的代码，它就在那里。尝试通过在其他各种标识符上调用:GoDescribe来测试输出是什么。 被问得最多的问题之一是如何知道一个类型正在实现的接口。假设您有一个类型和一个由多个方法组成的方法集。您想知道它可能实现哪个接口。guru的模式implement就是这样做的，它有助于找到一个类型实现的接口。 只需继续前一个main.go文件。将光标放在handler标识符上main()函数之后。Call:GoImplements您将看到一个位置列表，其中包含以下内容： 123main.go|23 col 6| chan type handler/usr/local/go/src/net/http/server.go|57 col 6| implements net/http.Handler 第一行是我们选择的类型，第二行是它实现的接口。因为一个类型可以实现许多接口，所以它是一个位置列表。 guru模式中可能有帮助的是whicherrs。如你所知，错误只是价值观。所以它们可以被编程，因此可以代表任何类型。看看guru手册上说的： whichers模式报告可能出现在类型error值中的一组可能的常量、全局变量和具体类型。在处理错误时，这些信息可能很有用，以确保所有重要的案件都得到处理。 那么我们如何使用它呢？很简单。我们仍然使用相同的main.go文件。将光标放在从http.ListenAndServe返回的err标识符的顶部。调用:GoWhicherrs，您将看到以下输出： 123456main.go|12 col 6| this error may contain these constants:/usr/local/go/src/syscall/zerrors_darwin_amd64.go|1171 col 2| syscall.EINVALmain.go|12 col 6| this error may contain these dynamic types:/usr/local/go/src/syscall/syscall_unix.go|100 col 6| syscall.Errno/usr/local/go/src/net/net.go|380 col 6| *net.OpError 您将看到err值可能是syscall.EINVAL常量，也可能是动态类型syscall.Errno或*net.OpError。如您所见，这在实现定制逻辑以不同方式处理错误时非常有用。注意，这个查询需要设置guruscope。稍后我们将介绍scope是什么，以及如何动态地更改它。 让我们继续使用相同的main.go文件。Go以其并发原语（如channels）而闻名。跟踪值如何在通道之间发送有时会很困难。为了更好地理解它，我们有peers模式guru。此查询显示通道操作数上可能的发送/接收集（发送或接收操作）。 将光标移到以下表达式并选择整行： 12ch &lt;- n 打电话给:GoChannelPeers。您将看到一个包含以下内容的位置列表窗口： 12345main.go|19 col 6| This channel of type chan&lt;- int may be:main.go|10 col 11| allocated heremain.go|19 col 6| sent to, heremain.go|27 col 53| received from, here 如您所见，您可以看到通道的分配，它从何处发送和接收。因为这使用指针分析，所以必须定义一个范围。 让我们看看函数调用和目标是如何相关的。这次创建以下文件。main.go的内容应为： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;github.com/fatih/vim-go-tutorial/example&quot;)func main() { Hello(example.GopherCon) Hello(example.Kenya)}func Hello(fn func() string) { fmt.Println(&quot;Hello &quot; + fn())} 文件应该在example/example.go下： 12345678910package examplefunc GopherCon() string { return &quot;GopherCon&quot;}func Kenya() string { return &quot;Kenya&quot;} 所以跳转到main.go中的Hello函数，并将光标放在名为fn()的函数调用的顶部。执行:GoCallees。此命令显示所选函数调用的可能调用目标。如您所见，它将向我们展示example函数中的函数声明。这些函数是被调用者，因为它们是由名为fn()的函数调用调用的。 再次跳回main.go，这次将光标放在函数声明Hello()上。如果我们想看到这个函数的调用者呢？执行:GoCallers。 您应该看到输出： 123main.go| 10 col 7 static function call from github.com/fatih/vim-go-tutorial.Mainmain.go| 11 col 7 static function call from github.com/fatih/vim-go-tutorial.Main 最后还有callstack模式，它显示从调用图根到包含选择的函数的任意路径。 将光标放回Hello()函数内的fn()函数调用。选择函数并调用:GoCallstack。输出应如下（简化形式）： 1234main.go| 15 col 26 Found a call path from root to (...)Hellomain.go| 14 col 5 (...)Hellomain.go| 10 col 7 (...)main 它从15行开始，然后到14行，然后在10行结束。这是从根（从main()开始）到我们选择的函数（在我们的例子中是fn()）的图 对于大多数guru命令，您不需要定义任何范围。什么是scope？以下摘录直接摘自guru手册： 指针分析范围：有些查询涉及指针分析，这是一种回答“这个指针可能指向什么”形式的问题的技术？”. 对工作区中的所有包运行指针分析通常开销太大，因此这些查询需要一个称为scope的附加配置参数，它决定要分析的包集。将作用域设置为当前正在使用的应用程序（或applications—a客户机和服务器的集合）。指针分析是whole-program分析，因此范围内唯一重要的包是主包和测试包。 作用域通常被指定为comma-separated包集，或者像github.com/my/dir/…这样的通配符子树；请参阅编辑器的特定文档，了解如何设置和更改范围。 vim-go自动尝试智能化，并为您将当前包导入路径设置为scope。如果命令需要一个作用域，那么大部分都可以覆盖。大多数情况下，这已经足够了，但是对于某些查询，您可能需要更改范围设置。为了便于动态更改scope，请使用一个名为:GoGuruScope的特定设置 如果您调用它，它将返回一个错误：guru scope is not set。让我们显式地将其更改为`github.com/fatih/vim-go-tutorial“范围： 12:GoGuruScope github.com/fatih/vim-go-tutorial 您应该看到以下消息： 12guru scope changed to: github.com/fatih/vim-go-tutorial 如果不带任何参数运行:GoGuruScope，它将输出以下内容 12current guru scope: github.com/fatih/vim-go-tutorial 要选择整个GOPATH，可以使用...参数： 12:GoGuruScope ... 您还可以定义多个包和子目录。以下示例选择github.com和golang.org/x/tools包下的所有包： 12:GoGuruScope github.com/... golang.org/x/tools 您可以通过在包前面加上-（负号）来排除包。以下示例选择encoding下而不是encoding/xml下的所有包： 12:GoGuruScope encoding/... -encoding/xml 要清除范围，只需传递一个空字符串： 12:GoGuruScope &quot;&quot; 如果您正在一个项目中工作，您必须将范围始终设置为相同的值，并且您不希望每次启动Vim时都调用:GoGuruScope，那么您还可以通过向vimrc添加一个设置来定义一个永久作用域。该值必须是字符串类型的列表。以下是上述命令中的一些示例： 12345let g:go_guru_scope = [&quot;github.com/fatih/vim-go-tutorial&quot;]let g:go_guru_scope = [&quot;...&quot;]let g:go_guru_scope = [&quot;github.com/...&quot;, &quot;golang.org/x/tools&quot;]let g:go_guru_scope = [&quot;encoding/...&quot;, &quot;-encoding/xml&quot;] 最后，vim-go会在使用:GoGuruScope时自动完成软件包。所以当你试图写github.com/fatih/vim-go-tutorial只需输入gi并点击tab，你会发现它会扩展到github.com 另一个需要注意的设置是构建标记（也称为构建约束）。例如，下面是您在Go源代码中放置的构建标记： 12// +build linux darwin 有时源代码中可能有自定义标记，例如： 12// +build mycustomtag 在这种情况下，guru将失败，因为底层的go/build包将无法构建该包。因此，所有guru相关的命令都将失败（即使:GoDef在使用guru时也是如此）。幸运的是，guru有一个-tags标志，允许我们传递自定义标记。为了方便vim-go用户，我们有一个:GoBuildTags 对于示例，只需调用以下命令： 12:GoBuildTags mycustomtag 这将把这个标记传递给guru，从现在起它将按预期工作。就像:GoGuruScope，你可以用以下方法清除它： 12:GoBuildTags &quot;&quot; 最后，如果您愿意，可以使用以下设置使其永久化： 12let g:go_build_tags = &quot;mycustomtag&quot; Refactor itRename identifiers重命名标识符是最常见的任务之一。但这也是一件需要小心处理的事情，以免破坏其他包裹。同样，仅仅使用sed这样的工具有时是没有用的，因为您希望能够感知AST的重命名，所以它只应该重命名属于AST的标识符（它不应该重命名其他非Go文件中的标识符，比如构建脚本） 有一个为您重命名的工具，名为gorename。vim-go使用:GoRename命令在引擎盖下使用gorename。让我们将main.go更改为以下内容： 1234567891011121314151617package mainimport &quot;fmt&quot;type Server struct { name string}func main() { s := Server{name: &quot;Alper&quot;} fmt.Println(s.name) // print the server name}func name() string { return &quot;Zeynep&quot;} 将光标放在Server结构中name字段的顶部，然后调用:GoRename bar。您将看到所有name引用都被重命名为bar。最终内容如下： 1234567891011121314151617package mainimport &quot;fmt&quot;type Server struct { bar string}func main() { s := Server{bar: &quot;Alper&quot;} fmt.Println(s.bar) // print the server name}func name() string { return &quot;Zeynep&quot;} 如您所见，只有必要的标识符被重命名，但是函数name或注释中的字符串没有被重命名。更好的是:GoRename搜索GOPATH下的所有包，并重命名依赖于该标识符的所有标识符。这是一个非常强大的工具。 Extract function让我们来看另一个例子。将main.go文件更改为： 1234567891011121314151617package mainimport &quot;fmt&quot;func main() { msg := &quot;Greetings\\nfrom\\nTurkey\\n&quot; var count int for i := 0; i &lt; len(msg); i++ { if msg[i] == '\\n' { count++ } } fmt.Println(count)} 这是一个基本示例，它只计算msg变量中的换行数。如果您运行它，您将看到它输出3。 假设我们想在其他地方重用换行计数逻辑。让我们重构它。在这些情况下，大师可以用freevars模式帮助我们。freevars模式显示在给定选择中被引用但未定义的变量。 让我们选择visual模式下的片段： 1234567var count intfor i := 0; i &lt; len(msg); i++ { if msg[i] == '\\n' { count++ }} 选择后，请致电:GoFreevars。它应该是:'&lt;,'&gt;GoFreevars的形式。结果又是一个快速修复列表，它包含了所有自由变量的变量。在我们的例子中，它是一个单一变量，结果是： 12var msg string 那么这有多有用呢？这一小块信息足以将其重构为一个独立的函数。创建包含以下内容的新函数： 12345678910func countLines(msg string) int { var count int for i := 0; i &lt; len(msg); i++ { if msg[i] == '\\n' { count++ } } return count} 您将看到内容是我们先前选择的代码。函数的输入是:GoFreevars，自由变量的结果。我们只决定归还什么（如果有的话）。在我们的情况下，我们返回计数。我们的main.go将采用以下形式： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() { msg := &quot;Greetings\\nfrom\\nTurkey\\n&quot; count := countLines(msg) fmt.Println(count)}func countLines(msg string) int { var count int for i := 0; i &lt; len(msg); i++ { if msg[i] == '\\n' { count++ } } return count} 这就是重构一段代码的方法。:GoFreevars也可以用来理解代码的复杂性。只需运行它，看看有多少变量与之相关。 Generate it代码生成是一个热门话题。因为有很棒的std libs，比如go/ast、go/parser、go/printer等。。围棋的优势在于能够轻松地创造出伟大的发电机。 首先我们有一个:GoGenerate命令，它在引擎盖下调用go generate。它就像:GoBuild，:GoTest，等等。。如果有任何错误，它也会显示它们，以便您可以轻松地修复它。 实现接口的方法存根接口对组合非常有用。它们使代码更容易处理。创建测试也更容易，因为您可以模拟接受接口类型的函数，该接口类型具有实现测试方法的类型。 vim-go支持工具impl。impl生成实现给定接口的方法存根。让我们将main.go的内容更改为以下内容： 12345678910package mainimport &quot;fmt&quot;type T struct{}func main() { fmt.Println(&quot;vim-go&quot;)} 将光标放在T的顶部，然后键入:GoImpl。系统将提示您编写接口。输入io.ReadWriteCloser，然后按enter键。您将看到内容更改为： 12345678910111213141516171819202122package mainimport &quot;fmt&quot;type T struct{}func (t *T) Read(p []byte) (n int, err error) { panic(&quot;not implemented&quot;)}func (t *T) Write(p []byte) (n int, err error) { panic(&quot;not implemented&quot;)}func (t *T) Close() error { panic(&quot;not implemented&quot;)}func main() { fmt.Println(&quot;vim-go&quot;)} 你看那真是太好了。当你在一个类型上面时，你也可以只输入:GoImpl io.ReadWriteCloser，它也会这样做。 但不需要将光标放在类型的顶部。你可以从任何地方调用它。例如，执行以下操作： 12:GoImpl b *B fmt.Stringer 您将看到将创建以下内容： 1234func (b *B) String() string { panic(&quot;not implemented&quot;)} 如您所见，这是非常有帮助的，特别是当您有一个带有大型方法集的大型接口时。您可以很容易地生成它，因为它使用panic()，所以编译时没有任何问题。只要把必要的部分填好就行了。 Share itvim-go还具有通过https://play.golang.org/与他人轻松共享代码的功能。正如你所知，围棋场是一个分享小片段、练习和/或提示和技巧的完美场所。有时候你在玩弄一个想法，想和别人分享。复制代码并访问play.golang.org，然后粘贴它。`vim-go`使用`:GoPlay`命令可以使所有这些都变得更好。 首先，让我们用以下简单代码更改main.go文件： 12345678package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;vim-go&quot;)} 现在调用:GoPlay，然后按enter键。您将看到vim-go自动上载了源代码:GoPlay，并且还打开了一个显示它的浏览器选项卡。但还有更多。代码段链接也会自动复制到剪贴板。只需将链接粘贴到某个地方。你会看到链接与正在播放的内容相同play.golang.org. :GoPlay也接受一个范围。您可以选择一段代码并调用:GoPlay。它只会上传所选的部分。 有两个设置可以调整:GoPlay的行为。如果您不喜欢vim-go为您打开一个浏览器选项卡，您可以使用以下命令禁用它： 12let g:go_play_open_browser = 0 其次，如果您的浏览器被错误检测到（我们使用的是open或xdg-open），您可以通过以下方式手动设置浏览器： 12let g:go_play_browser_command = &quot;chrome&quot; HTML template默认情况下，.tmpl文件启用了gohtml模板的语法高亮显示。如果要为另一个文件类型启用它，请将以下设置添加到.vimrc： 12au BufRead,BufNewFile *.gohtml set filetype=gohtmltmpl Donation本教程是我在业余时间创作的。如果你喜欢并愿意捐款，你现在可以成为一个完全的支持者，成为一个赞助人！ 作为一个用户，你使vim-go成长和成熟，帮助我投资于错误修复、新文档，并改进当前和未来的功能。它是完全可选的，只是支持vim-go’s正在进行的开发的一种直接方法。谢谢！ https://www.patreon.com/fatih TODO Commands :GoPath :AsmFmt","link":"/2022/02/09/Tutorial%20for%20vim-go/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 excerpt Page excerpt in plain text. Use this plugin to format the text disableNunjucks Disable rendering of Nunjucks tag {{ }}/{% %} and tag plugins when enabled lang Set the language to override auto-detection Inherited from _config.yml","link":"/2021/06/13/hello-world/"},{"title":"ios 读取csv文件","text":"最终代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 .fileImporter(isPresented: $imported, allowedContentTypes: [.delimitedText], allowsMultipleSelection: false){ result in do { guard let fileUrl: URL = try result.get().first else {return} if (CFURLStartAccessingSecurityScopedResource(fileUrl as CFURL)) { //不在这个if里就出错，唉 //理由：iOS的沙盒机制保护需要我们申请临时调用url的权限 guard let data = String(data: try Data(contentsOf: fileUrl), encoding: .utf8) else { return } handleSSJdataCSV(data: data) //done accessing the url CFURLStopAccessingSecurityScopedResource(fileUrl as CFURL) } else { print(&quot;Permission error!&quot;) } } catch { // Handle failure. print (&quot;error reading: \\(error.localizedDescription)&quot;) }} //数据格式处理代码 func handleSSJdataCSV(data : String){ var csvToStruct = [SSJdata]() //split the long string into an array of &quot;rows &quot; of sata. each row is a string //detect &quot;/n&quot; carriage return , then split var rows = data.components(separatedBy: &quot;\\n&quot;) let columnCount = rows.first?.components(separatedBy: &quot;,&quot;).count //remove the header rows rows.removeFirst() //loop around each row and split into columns for row in rows{ let csvColumes = row.components(separatedBy: &quot;,&quot;) if csvColumes.count == columnCount{ let genericStruct = SSJdata.init( raw: csvColumes) csvToStruct.append(genericStruct!) } } print(csvToStruct) for singleRecord in csvToStruct{ print(singleRecord.recordType) } //done accessing the url} 参考文献：https://stackoverflow.com/questions/67731694/how-do-i-save-an-imported-file-name-as-string-after-importing-file-in-swiftui 12345//不太管用let fileUrl = try res.get() self.fileName = fileUrl.lastPathComponent // &lt;--- the file name you want let fileData = try Data(contentsOf: fileUrl) https://betterprogramming.pub/importing-and-exporting-files-in-swiftui-719086ec712有大用https://github.com/acwright/ImportExport上面那个链接内容的示范工程","link":"/2021/11/24/ios%20%E8%AF%BB%E5%8F%96csv%E6%96%87%E4%BB%B6/"},{"title":"iterm2 + zsh 环境配置","text":"1. 先安装homebrew 和 iterm22. 从catalina开始，zsh是所有新建用户账户的默认shell，不需要重新安装。3. 安装 oh-my-zsh 。https://github.com/ohmyzsh/ohmyzsh 4. 安装 两个插件：git clone https://github.com/zsh-users/zsh-syntax-highlighting ${ZSH_CUSTOM:-/.oh-my-zsh/custom}/plugins/zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 5.编辑.zshrc文件6. 安装主题， powerlevel10khttps://github.com/romkatv/powerlevel10k#homebrew 7.安装colorlshttps://github.com/athityakumar/colorlssudo gem install colorls 8.代码统计工具brew install cloc","link":"/2022/01/26/iterm2%20+%20zsh%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"《大江东去》摘录","text":"大江东去 庙堂之人可以结交，人们从来都是这么在做，而鸡鸣狗盗之徒也可以入幕，过去的孟尝君曾因此脱厄。用人，该有胸怀，该不拘一格。 了解局势，了解矛盾，就中游走，顺势而为，往往事半功倍 辩论这东西，如果有权威加入，辩论结果就是权威者的意志，其他人言多必失；如果没有权威加入，真正百花齐放，一千个人心中有一千个哈姆莱特，真理从来不是越辩越明，而是辩论到最后每个人更坚信自己心中的哈姆莱特是正宗。辩论的最后肯定不是摆事实讲道理，而是挑逻辑错误玩文字游戏搞狡辩。这种辩论还有什么意义？还不如回寝室开卧谈会。 有些人，即使有再好的想法，可不会管理，不能将自己的思想贯彻下去，最终想法都成空话。而最可怕的是，有些人做不成事，却埋怨社会不公，奸人当道，给自己找失败理由，其实这些都不是理由。一个人想做成事，遇到的不是一个两个人，而是很多，形形色色的社会人都能遇到。社会这样对这人，也是这样对那人，没太大区别。有些人就是不能回头思考，为什么就他面前奸人特别多，社会特不公平，究竟错在哪里 每一个集体都有一群被既有管理者挡住去路的蠢蠢欲动者，每个蠢蠢欲动者都希望绕过挡道者越位而出，为此，每个蠢蠢欲动者都有设法展示的必要：展示其技能，展示其忠诚。而竞聘，就是宋运辉堂而皇之地给予那些蠢蠢欲动者展示自己的机会。宋运辉心中早有人选，但是他需要竞聘这样一个跳出惯例，却又合情合理的程序。 别有意去破坏。一个国家或者一个家庭如果用破坏传统的方式去发展人文，这很危险，一定弄得人民无所适从。 正好韦春红跟他提起农历二月十九是观音菩萨的生日，雷东宝毫不犹豫答应陪韦春红一起去，好好烧柱香，做些功德。","link":"/2021/04/05/%E5%A4%A7%E6%B1%9F%E4%B8%9C%E5%8E%BB/"},{"title":"崽崽","text":"纪念一下我的小兔几，你在那边和其他小伙伴玩好。","link":"/2021/04/04/%E5%B4%BD%E5%B4%BD/"},{"title":"摘录-关于工作、欲望、生活、健康","text":"我觉得我最大的极简，就是少受累，保养身体，珍爱自己的生命。 挑一个性价比最高的工作，每天八小时，双休，时薪约70元。我知道我同学有选择了996的，他们挣得很多，时薪大约是我的一半。 挑一个人际关系冷漠很少团建聚餐的工作。这样不是因为我不喜欢热闹，我只是不喜欢攀比。别人炫耀名牌首饰包包名车名表的时候，我就当看不见。别人抱怨自己月光欠花呗，那都与我无关。 我和我老公都是低欲望的人，能靠家长出首付，我们就是要理直气壮的啃老，也不会996去伤身体挣那几个臭钱。既然有的选，那我们就是不肯996。毕竟我爸妈当年也是靠姥姥姥爷买的房，我们将来有钱了也会接济孩子，这样想来可不就是理直气壮吗。 脱离世俗，想想自己的理想。想想自己真正喜欢做什么。同事有贷款买豪车充门面的，我俩工薪阶层工程师，上班又不远不用车，要门面干嘛，买个十几万的车，到处去玩就足够了。 人家梦龙雪糕都不要脸的不用牛奶了，什么玩意，那些外头买的东西，又贵又舍不得用好材料还好意思说为了环保。我就自己冻酸奶雪糕吃，自己拿纯牛奶做冰淇淋。还有自己蒸馒头，烤肉，打豆浆，做果冻，奶茶，柠檬红茶。真特么的香。反正下班有的是时间。 我们还要互相捏肩捶腿，好好保养。天热喝绿豆汤，天冷喝姜汤，周末自己磨个咖啡，香飘整屋。 我每天晚上都能看着老公送我的一架古筝，弹几个曲子，总觉得好幸福啊，这可比买首饰好听多了，还要啥自行车。 我们晚上常坐在阳台上，喝点小酒，看星星看月亮。周末我喜欢玩手机，听音乐，看看闲书。 我家的老人，都是五十多就不用务农或上班了，要么半退休。能够身体健康的直到90岁，天天晨练逛公园，自己做饭，还能领几十年退休金。身体好是真的好。 作者：鸿飞满西洲 链接：https://www.zhihu.com/question/313020218/answer/2077887482 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2021/08/24/%E9%9A%8F%E6%83%B3%E6%91%98%E5%BD%95/"},{"title":"项目重构","text":"数据结构设计摒弃原来的多层结构，只用一层数据结构设计，并且使用relationships 关系 account设计（兼顾账户和第二类型） accountID balance（余额） counted icon name note type 支出 收入 普通账户 信用账户 投资账户 借贷账户 billingData： 账单日 credit creditLimit： 额度 credit repaymentDate： 还款日 credit rate： 百分比：利息什么的 installment ， loan autoCalculate installment， loan installmentType ： installment， loan destinationAccount ： loan installmentTimes： 期数 loan installmentType： 年月日 loan isDEBJ： 等额本金 loan isMoneyIn： 进、出 loan person： 借贷对象 loan state： 是否结清 loan timesInterest： 单次利息 loan timesLeft： 剩余期数 loan","link":"/2021/11/28/%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E7%AC%94%E8%AE%B0/"},{"title":"数据库范式","text":"– 1NF列的原子性,列的内容不可再分割 学生表(学号、姓名、年龄、性别、地址)。地址可以细分为国家、省份、城市、市区、街道，那么该模式就没有达到第一范式。 第一范式存在问题：冗余度大、会引起修改操作的不一致性、数据插入异常、数据删除异常。 2NF非主键完全依赖主键(确保每列都和主键直接相关)(表必须有主键ID) 版本表(版本编码，版本名称，产品编码，产品名称)，其中主键是(版本编码，产品编码)，这个场景中，数据库设计并不符合第二范式，因为产品名称只依赖于产品编码。存在部分依赖。所以，为了使其满足第二范式，可以改造成两个表：版本表(版本编码，产品编码)和产品表(产品编码，产品名称) 3NF 属性不依赖于其他非主属性(不传递依赖)不能存在非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。(数据库中的一个表不包含已在其他表中已包含的非主关键字信息)(除主键以外的列,不存在某个列,能决定其他列)(确保每列都和主键列直接相关,而不是间接相关) 订单表(订单编码，顾客编码，顾客名称)，其中主键是(订单编码)，这个场景中，顾客编码、顾客名称都完全依赖于主键，因此符合第二范式，但顾客名称依赖于顾客编码，从而间接依赖于主键，所以不能满足第三范式。如果要满足第三范式，需要拆分为两个表：订单表(订单编码，顾客编码)和顾客表(顾客编码，顾客名称)。 2NF和3NF的区别关键点· 2NF: 非主键是否完全依赖于主键,还是依赖于主键的一部分· 3NF: 非主键列是直接依赖于主键,还是直接依赖于非主键列 BCDF范式(鲍伊斯-科得范式,3NF改进形式) 在第三的基础上, 数据库表中不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式防止主键的某一列会依赖于主键的其他列。当3NF消除了主属性对码的部分函数依赖和传递函数依赖称为BCNF。 特性： 1、所有主属性对每一个码都是完全函数依赖 2、所有主属性对每一个不包含它的码，也是完全函数依赖 3、没有任何属性完全函数依赖与非码的任何一组属性 库存表(仓库名，管理员名，商品名，数量)，主键为(仓库名，管理员名，商品名)，这是满足前面三个范式的，但是仓库名和管理员名之间存在依赖关系，因此删除某一个仓库，会导致管理员也被删除，这样就不满足BCNF。 4NF非主属性不应该有多值。如果有多值就违反了第四范式。4NF是限制关系模式的属性间不允许有非平凡且非函数依赖的多值依赖。 用户联系方式表(用户id，固定电话，移动电话)，其中用户id是主键，这个满足了BCNF,但是一个用户有可能会有多个固定电话或者多个移动电话，那么这种设计就不合理，应该改为(用户id，联系方式类型，电话号码)。 如果只考虑函数依赖，关系模式规范化程度最高的范式是BCNF;如果考虑多值依赖则是4NF 5NF第五范式属于最终范式，消除了4NF中的连接依赖，第五范式需要满足以下要求： 1、必须满足第四范式 2、表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。 一般实际应用中不必考虑第五范式。","link":"/2022/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"},{"title":"黑群晖安装QB","text":"打开docker， 输入qbittorrent， 找到 linuxserver/qbittorrent 下载 创建qb文件夹，改everyone权限，内建两个新子文件夹，config和downloads docker映像设置中添加卷来映射文件夹 改端口，第三个tcp是webui端口，其他的也要改，默认的6881被大多数站点屏蔽。 配置环境变量 下一步。确认，运行。 登录qb界面，默认账户admin，默认密码 adminadmin 修改qb的连接中的监听端口为修改过的端口 意外情况：QB无法打开，提示错误：/usr/bin/qbittorrent-nox: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory解决方法： ssh 到 群晖，然后docker exec -it qbittorrent4.3.3 /bin/shqbittorrent4.3.3 是我容器名，参照自已的改 apt update apt install binutils strip –remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5 重启容器 参考文献：http://www.360doc.com/content/19/0601/19/27498460_839666036.shtmlhttps://post.smzdm.com/p/a7do76vd/https://github.com/linuxserver/docker-qbittorrent/issues/103","link":"/2021/06/25/%E9%BB%91%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85QB/"},{"title":"2023影单","text":"黑炮事件2023-01-07 黑亚当2023-01-23 风云·雄霸天下2023-02-10 狂飙2023-03-04 乔家大院2023-04-03 阿凡达·水之道2023-04-06 流浪地球22023-05-03 黑豹22023-05-07 蚁人与黄蜂女2023-05-08 天下粮仓（电视剧）2023-05-15 猩球崛起·猿人争霸战 20112023-05-21 猩球崛起·黎明之战 20142023-05-23 猩球崛起·终极之战 20172023-05-27 西游记19862023-05-27","link":"/2023/01/01/2023%20%E5%BD%B1%E5%8D%95/"}],"tags":[{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"书单","slug":"书单","link":"/tags/%E4%B9%A6%E5%8D%95/"},{"name":"计算机学习笔记","slug":"计算机学习笔记","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"VIM","slug":"VIM","link":"/tags/VIM/"},{"name":"利其器","slug":"利其器","link":"/tags/%E5%88%A9%E5%85%B6%E5%99%A8/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"SwiftUI","slug":"SwiftUI","link":"/tags/SwiftUI/"},{"name":"环境安装","slug":"环境安装","link":"/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"},{"name":"GO","slug":"GO","link":"/tags/GO/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"读书摘录","slug":"读书摘录","link":"/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95/"},{"name":"回忆","slug":"回忆","link":"/tags/%E5%9B%9E%E5%BF%86/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"范式","slug":"范式","link":"/tags/%E8%8C%83%E5%BC%8F/"},{"name":"BCNF","slug":"BCNF","link":"/tags/BCNF/"},{"name":"NAS","slug":"NAS","link":"/tags/NAS/"},{"name":"下载","slug":"下载","link":"/tags/%E4%B8%8B%E8%BD%BD/"}],"categories":[{"name":"阅尽千帆","slug":"阅尽千帆","link":"/categories/%E9%98%85%E5%B0%BD%E5%8D%83%E5%B8%86/"},{"name":"重剑无锋","slug":"重剑无锋","link":"/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/"},{"name":"九阴真经","slug":"九阴真经","link":"/categories/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/"},{"name":"闲情雅致","slug":"闲情雅致","link":"/categories/%E9%97%B2%E6%83%85%E9%9B%85%E8%87%B4/"},{"name":"环境配置","slug":"重剑无锋/环境配置","link":"/categories/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"形影尘寰","slug":"形影尘寰","link":"/categories/%E5%BD%A2%E5%BD%B1%E5%B0%98%E5%AF%B0/"},{"name":"归来少年","slug":"归来少年","link":"/categories/%E5%BD%92%E6%9D%A5%E5%B0%91%E5%B9%B4/"},{"name":"数据库","slug":"九阴真经/数据库","link":"/categories/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}